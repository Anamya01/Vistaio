"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSchemaElement = exports.createOrUpdateSdlDirective = void 0;
const fs = require("fs");
const graphql_1 = require("graphql");
const path = require("path");
const graphql_helpers_1 = require("./graphql-helpers");
const print_1 = require("../actions/print");
const constants_1 = require("./constants");
const copy_workspace_content_1 = require("./copy-workspace-content");
const normalizePathSep = (pathlike) => pathlike.replace(path.sep, path.posix.sep);
const createOrUpdateSdlDirective = (importedGraphQLFiles, allGraphQLFiles, origSdlDirective) => {
    let sdlDirective;
    if (origSdlDirective) {
        sdlDirective = (0, graphql_helpers_1.cloneDeep)(origSdlDirective);
    }
    else {
        sdlDirective = {
            kind: graphql_1.Kind.DIRECTIVE,
            name: {
                kind: graphql_1.Kind.NAME,
                value: 'sdl',
            },
            arguments: [
                {
                    kind: graphql_1.Kind.ARGUMENT,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: 'files',
                    },
                    value: {
                        kind: graphql_1.Kind.LIST,
                        values: [
                            {
                                kind: graphql_1.Kind.STRING,
                                value: constants_1.ALL_GRAPHQL_FILES,
                            },
                        ],
                    },
                },
            ],
        };
    }
    sdlDirective.arguments = sdlDirective.arguments?.map(arg => {
        if (arg.name.value === 'files') {
            const filesValueNodes = arg.value;
            const fileset = new Set([
                ...filesValueNodes.values.map(value => value.value),
                ...importedGraphQLFiles,
                // Make sure paths in the `@sdl()` directive use the `/` separator
                // even on Windows.
            ].map(normalizePathSep));
            if (fileset.has(constants_1.ALL_GRAPHQL_FILES)) {
                fileset.delete(constants_1.ALL_GRAPHQL_FILES);
                allGraphQLFiles.forEach(file => fileset.add(normalizePathSep(file)));
            }
            filesValueNodes.values = [...fileset].map(file => ({
                kind: graphql_1.Kind.STRING,
                value: file,
            }));
        }
        return arg;
    });
    return sdlDirective;
};
exports.createOrUpdateSdlDirective = createOrUpdateSdlDirective;
const createSchemaElement = (importedGraphQLFiles, allGraphQLFiles) => {
    const schemaElement = {
        kind: graphql_1.Kind.SCHEMA_DEFINITION,
        directives: [
            (0, exports.createOrUpdateSdlDirective)(importedGraphQLFiles, allGraphQLFiles),
        ],
        operationTypes: [
            {
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                operation: graphql_1.OperationTypeNode.QUERY,
                type: {
                    kind: graphql_1.Kind.NAMED_TYPE,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: 'Query',
                    },
                },
            },
        ],
    };
    return schemaElement;
};
exports.createSchemaElement = createSchemaElement;
exports.default = (source, importedGraphQLFiles) => {
    const allGraphQLFiles = (0, copy_workspace_content_1.getAllGraphQLFiles)(source);
    const output = path.join(source, 'index.graphql');
    const index = fs.readFileSync(output, 'utf8');
    let hasSchemaElement;
    let ast = (0, graphql_1.parse)(index);
    ast = (0, graphql_1.visit)(ast, {
        SchemaDefinition(node) {
            hasSchemaElement = true;
            const mutated = (0, graphql_helpers_1.cloneDeep)(node);
            const idx = mutated.directives?.findIndex(directive => directive.name.value === 'sdl');
            if (mutated.directives && idx !== undefined && idx > -1) {
                mutated.directives[idx] = (0, exports.createOrUpdateSdlDirective)(importedGraphQLFiles, allGraphQLFiles, mutated.directives[idx]);
            }
            else {
                mutated.directives = mutated.directives || [];
                mutated.directives.push((0, exports.createOrUpdateSdlDirective)(importedGraphQLFiles, allGraphQLFiles));
            }
            return mutated;
        },
    });
    if (!hasSchemaElement) {
        ast = (0, graphql_1.visit)(ast, {
            Document(node) {
                const mutated = (0, graphql_helpers_1.cloneDeep)(node);
                mutated.definitions.push((0, exports.createSchemaElement)(importedGraphQLFiles, allGraphQLFiles));
                return mutated;
            },
        });
    }
    fs.writeFileSync(output, (0, print_1.default)(ast));
};
//# sourceMappingURL=set-files-in-sdl.js.map
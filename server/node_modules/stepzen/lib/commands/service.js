"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const errors_1 = require("@oclif/core/lib/errors");
const dsn_parser_1 = require("@soluble/dsn-parser");
const fetch_1 = require("@stepzen/fetch");
const chalk = require("chalk");
const debug = require("debug");
const lodash_1 = require("lodash");
const path = require("path");
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
const puka_1 = require("puka");
const shell = require("shelljs");
const configuration_1 = require("../shared/configuration");
const constants_1 = require("../shared/constants");
const docker_1 = require("../shared/docker");
const inquirer = require("../shared/inquirer");
const url_helpers_1 = require("../shared/url-helpers");
const utils_1 = require("../shared/utils");
const zen_command_1 = require("../shared/zen-command");
const DEFAULT_ZEN_PORT = 9000;
const dsnQuestions = [
    {
        name: 'host',
        message: 'What is the database host?',
        validate: input => (0, url_helpers_1.parseHost)(input).isValid || `Could not parse "${input}" as a hostname.`,
    },
    {
        name: 'database',
        message: 'What is the database name?',
        validate: input => input.trim() !== '' || 'Database name must not be empty',
    },
    {
        name: 'user',
        message: 'What is the username?',
        validate: input => input.trim() !== '' || 'Username must not be empty',
    },
    {
        name: 'password',
        message: 'What is the password?',
        type: 'password',
    },
];
class Service extends zen_command_1.default {
    async run() {
        const { args, flags } = await this.parse(Service);
        await this.ensureDockerInPath();
        let status = await this.getDockerContainerStatus(constants_1.STEPZEN_CONTAINER_NAME);
        switch (args.action) {
            case 'start':
                switch (status) {
                    case 'not-created':
                        status = await this.createDockerContainers(flags);
                    // eslint-disable-next-line no-fallthrough
                    case 'created':
                    case 'exited': {
                        const port = (await this.getPorts(flags)).port;
                        // this would be the case when Docker is restarted
                        const result = await this.startDockerContainers(port);
                        await this.createLocalCredentialsFile({
                            port: flags.port || DEFAULT_ZEN_PORT,
                            credentials: result.credentials,
                        });
                        status = result.status;
                        this.log();
                    }
                    // eslint-disable-next-line no-fallthrough
                    default:
                        await this.printServiceStatusMessage(status);
                }
                break;
            case 'stop':
                switch (status) {
                    case 'running':
                        status = await this.stopDockerContainers();
                    // eslint-disable-next-line no-fallthrough
                    default:
                        status = await this.removeDockerContainers();
                        this.log();
                    // eslint-disable-next-line no-fallthrough
                    case 'not-created':
                        await this.printServiceStatusMessage(status);
                }
                break;
            case 'upgrade': {
                const { result: versions, error } = await (0, docker_1.getDockerImageVersions)();
                if (error) {
                    throw new errors_1.CLIError(`Could not upgrade the local StepZen service. ` + error.message);
                }
                if (versions.local === versions.latest) {
                    this.log('The local StepZen docker image is already the latest.');
                    this.exit();
                }
                const initialStatus = status;
                switch (status) {
                    case 'running':
                        core_1.ux.action.start(chalk `Stopping the {bold ${constants_1.STEPZEN_CONTAINER_NAME}} Docker container`);
                        try {
                            await this.stopDockerContainer(constants_1.STEPZEN_CONTAINER_NAME);
                        }
                        catch (error) {
                            core_1.ux.action.stop('fail');
                            throw error;
                        }
                        core_1.ux.action.stop('done');
                    // eslint-disable-next-line no-fallthrough
                    default: {
                        const dsn = await this.getDsnFromDockerContainer();
                        await this.removeDockerContainers();
                        status = await this.createDockerContainers({
                            ...flags,
                            dsn: this.validateProvidedDsn(flags) || dsn,
                        });
                        if (initialStatus === 'running') {
                            core_1.ux.action.start(chalk `Starting the {bold ${constants_1.STEPZEN_CONTAINER_NAME}} Docker container`);
                            try {
                                status = await this.startDockerContainer(constants_1.STEPZEN_CONTAINER_NAME);
                            }
                            catch (error) {
                                core_1.ux.action.stop('fail');
                                throw error;
                            }
                            core_1.ux.action.stop('done');
                        }
                    }
                    // eslint-disable-next-line no-fallthrough
                    case 'not-created':
                        await this.printServiceStatusMessage(status);
                }
                break;
            }
            default:
                await this.printServiceStatusMessage(status);
        }
    }
    async getPorts(flags) {
        const config = await (0, configuration_1.readConfiguration)();
        const legacyPorts = new Set();
        if (config.serviceInstance &&
            'zenctl2' in config.serviceInstance &&
            (0, url_helpers_1.isLocalhost)(config.serviceInstance.zenctl2)) {
            const zenservPort = (0, url_helpers_1.getPortFromUrl)(config.serviceInstance.zenctl2);
            if (!flags.port && zenservPort !== DEFAULT_ZEN_PORT) {
                // see https://github.com/steprz/stepzen-cli/issues/956
                legacyPorts.add(zenservPort);
            }
            if (!flags.port &&
                'introspection' in config.serviceInstance &&
                config.serviceInstance.introspection) {
                // backwards compatibility
                legacyPorts.add((0, url_helpers_1.getPortFromUrl)(config.serviceInstance.introspection));
            }
            if (!flags.port &&
                'dbintrospection' in config.serviceInstance &&
                config.serviceInstance.dbintrospection) {
                // backwards compatibility
                legacyPorts.add((0, url_helpers_1.getPortFromUrl)(config.serviceInstance.dbintrospection));
            }
        }
        const port = flags.port || DEFAULT_ZEN_PORT;
        // do not bind the same port multiple times
        legacyPorts.delete(port);
        return { port, legacyPorts };
    }
    async ensureDockerInPath() {
        if (!shell.which('docker')) {
            throw new errors_1.CLIError(chalk `{bold stepzen service} needs Docker CLI to be installed, but could not find it.` +
                chalk `\nPlease check that the {bold docker} binary is in PATH and try again.`);
        }
    }
    async getDockerContainerStatus(containerName) {
        const command = `docker container list --all --filter "name=^${containerName}$" --format "{{.State}}"`;
        debug('stepzen:service')(chalk `running {cyan ${command}}`);
        const result = shell.exec(command, { silent: true });
        if (result.code) {
            throw new errors_1.CLIError(`failed to connect to Docker` +
                `\nCommand failed: ${command}` +
                `\n` +
                `\n${chalk.dim((0, utils_1.prependEachLine)(result.stderr, '[docker] '))}` +
                `\n` +
                `\nPlease make sure Docker is running, and you are using the latest` +
                ` StepZen CLI version.` +
                `\nIf the issue persists contact support via the StepZen discord ` +
                `channel (${constants_1.STEPZEN_DISCORD_URL}).`);
        }
        const status = (result.stdout.trim() ||
            'not-created');
        debug('stepzen:service')(`\t--> ${status}`);
        return status;
    }
    async ensureDockerNetwork() {
        // set up stepzen-network for container networking if it does not exist
        const inspectCommand = `docker network list --filter "name=^${constants_1.STEPZEN_CONTAINER_NETWORK}$" --format "{{.Driver}}"`;
        debug('stepzen:service')(chalk `running {cyan ${inspectCommand}}`);
        const inspectResult = shell.exec(inspectCommand, { silent: true });
        if (inspectResult.code) {
            throw new errors_1.CLIError(`failed to connect to Docker` +
                `\nCommand failed: ${inspectCommand}` +
                `\n` +
                `\n${chalk.dim((0, utils_1.prependEachLine)(inspectResult.stderr, '[docker] '))}` +
                `\n` +
                `\nPlease make sure Docker is running, and you are using the latest` +
                ` StepZen CLI version.` +
                `\nIf the issue persists contact support via the StepZen discord ` +
                `channel (${constants_1.STEPZEN_DISCORD_URL}).`);
        }
        if (inspectResult.stdout.trim()) {
            // stepzen-network already exists
            return;
        }
        core_1.ux.action.start(chalk `Creating the {bold ${constants_1.STEPZEN_CONTAINER_NETWORK}} network`);
        const createCommand = `docker network create -d bridge ${constants_1.STEPZEN_CONTAINER_NETWORK}`;
        debug('stepzen:service')(chalk `running {cyan ${createCommand}}`);
        const createResult = shell.exec(createCommand, { silent: true });
        if (createResult.code !== 0) {
            core_1.ux.action.stop('fail');
            throw new errors_1.CLIError(`failed to create a StepZen Docker network.` +
                `\nCommand failed: ${createCommand}` +
                `\n` +
                `\n${chalk.dim((0, utils_1.prependEachLine)(createResult.stderr, '[docker] '))}` +
                `\n` +
                `\nPlease make sure Docker is running, and you are using the` +
                ` latest StepZen CLI version.` +
                `\nIf the issue persists contact support via the StepZen discord ` +
                `channel (${constants_1.STEPZEN_DISCORD_URL}).`);
        }
        core_1.ux.action.stop('done');
    }
    async createDockerContainers(flags) {
        const useAutoDb = (flags.dsn === undefined || flags.dsn === constants_1.STEPZEN_AUTODB_DSN) &&
            !flags.prompt;
        // For auto-provisioned metadata db, use `stepzen-network` so that the
        // db port doesn't need to be exposed on the host. This reduces the risk
        // of port clashes.
        const network = useAutoDb ? constants_1.STEPZEN_CONTAINER_NETWORK : undefined;
        let dsn;
        if (useAutoDb) {
            this.log(`StepZen CLI uses an automatically-managed metadata database, running in a` +
                ` local Docker container.`);
            let dbStatus = await this.getDockerContainerStatus(constants_1.STEPZEN_AUTODB_CONTAINER_NAME);
            if (flags['reset-auto'] && dbStatus !== 'not-created') {
                (0, configuration_1.removeCredentialsAndServiceFromConfigFile)();
                this.removeDockerContainer({
                    containerName: constants_1.STEPZEN_AUTODB_CONTAINER_NAME,
                    ignoreErrors: true,
                });
                dbStatus = 'not-created';
            }
            if (dbStatus === 'not-created') {
                await this.ensureDockerNetwork();
                await this.createDockerContainer({
                    image: constants_1.STEPZEN_AUTODB_IMAGE,
                    containerName: constants_1.STEPZEN_AUTODB_CONTAINER_NAME,
                    environment: {
                        POSTGRES_USER: constants_1.STEPZEN_AUTODB_USER,
                        POSTGRES_PASSWORD: constants_1.STEPZEN_AUTODB_PASSWORD,
                        POSTGRES_DB: constants_1.STEPZEN_AUTODB_DATABASE,
                    },
                    secretMasker: { STEPZEN_CONTROL_DB_DSN: utils_1.maskPasswordInDsn },
                    ports: [],
                    pull: 'missing',
                    network,
                    hostGatewayParameter: false,
                });
            }
            dsn = constants_1.STEPZEN_AUTODB_DSN;
        }
        else if (flags.dsn === '' || flags.prompt) {
            this.log(`StepZen Docker container is stateless. It needs a connection to a` +
                ` StepZen metadata database to run.`);
            const answers = await inquirer.prompt('service', dsnQuestions);
            this.log();
            const { host, port } = (0, url_helpers_1.parseHost)(answers.host);
            dsn = `postgres://${encodeURIComponent(answers.user)}:${encodeURIComponent(answers.password)}@${encodeURIComponent(host)}:${port || 5432}/${encodeURIComponent(answers.database)}`;
        }
        else {
            dsn = this.validateProvidedDsn(flags);
        }
        const image = await (0, configuration_1.getStepZenDockerImage)();
        await this.ensureDockerNetwork();
        const { port, legacyPorts } = await this.getPorts(flags);
        await this.createDockerContainer({
            image,
            containerName: constants_1.STEPZEN_CONTAINER_NAME,
            environment: { STEPZEN_CONTROL_DB_DSN: dsn },
            secretMasker: { STEPZEN_CONTROL_DB_DSN: utils_1.maskPasswordInDsn },
            ports: [
                { host: port, container: 9000 },
                ...[...legacyPorts].map(port => ({ host: port, container: port })),
            ],
            pull: 'always',
            network,
            // host.docker.internal needs to be explicitly enabled on Linux, see e.g.:
            // https://medium.com/@TimvanBaarsen/how-to-connect-to-the-docker-host-from-inside-a-docker-container-112b4c71bc66
            hostGatewayParameter: process.platform === 'linux',
        });
        return 'created';
    }
    async createDockerContainer(args) {
        const fmtCommand = (env) => `docker container create` +
            ` --pull ${args.pull}` +
            (args.network ? ` --network ${args.network}` : '') +
            ` --name ${args.containerName}` +
            (args.hostGatewayParameter
                ? ' --add-host host.docker.internal:host-gateway'
                : '') +
            Object.entries(env)
                .map(([name, val]) => (0, puka_1.sh) ` --env ${name}=${val}`)
                .join('') +
            args.ports
                .map(port => ` --publish ${port.host}:${port.container}`)
                .join('') +
            ` ${args.image}`;
        const command = fmtCommand(args.environment);
        debug('stepzen:service')(chalk `running {cyan ${command}}`);
        core_1.ux.action.start(chalk `Creating a {bold ${args.containerName}} Docker container`);
        const result = shell.exec(command, { silent: true });
        if (result.code !== 0) {
            core_1.ux.action.stop(chalk.red('fail'));
            const maskedEnv = Object.fromEntries(Object.entries(args.environment).map(([name, val]) => [
                name,
                (args.secretMasker[name] || (x => x))(val),
            ]));
            const maskedCommand = fmtCommand(maskedEnv);
            throw new errors_1.CLIError(`failed to create a StepZen Docker container.` +
                `\nCommand failed: ${maskedCommand}` +
                `\n` +
                `\n${chalk.dim((0, utils_1.prependEachLine)(result.stderr, '[docker] '))}` +
                `\n` +
                `\nPlease make sure Docker is running, your network connection is` +
                ` stable, and you are using the latest StepZen CLI version.` +
                `\nIf the issue persists contact support via the StepZen discord ` +
                `channel (${constants_1.STEPZEN_DISCORD_URL}).`);
        }
        core_1.ux.action.stop('done');
    }
    async startDockerContainer(containerName) {
        const command = `docker container start ${containerName}`;
        debug('stepzen:service')(chalk `running {cyan ${command}}`);
        const result = shell.exec(command, { silent: true });
        if (result.code !== 0) {
            throw new errors_1.CLIError(`failed to start a StepZen Docker container.` +
                `\nCommand failed: ${command}` +
                `\n` +
                `\n${chalk.dim((0, utils_1.prependEachLine)(result.stderr, '[docker] '))}`);
        }
        const status = await this.getDockerContainerStatus(containerName);
        if (status !== 'running') {
            await this.removeDockerContainers({ ignoreErrors: true });
            throw new errors_1.CLIError(`failed to start a Docker container.` +
                `\nThe container status changed to '${status}' instead of 'running'.`);
        }
        return 'running';
    }
    async startDockerContainers(port) {
        const dsn = await this.getDsnFromDockerContainer();
        const toStart = [constants_1.STEPZEN_CONTAINER_NAME];
        if (dsn === constants_1.STEPZEN_AUTODB_DSN) {
            // start stepzen-metadata container if it exists and auto-managed DB has been requested
            const autodbStatus = await this.getDockerContainerStatus(constants_1.STEPZEN_AUTODB_CONTAINER_NAME);
            if (autodbStatus === 'created' || autodbStatus === 'exited') {
                toStart.push(constants_1.STEPZEN_AUTODB_CONTAINER_NAME);
            }
        }
        core_1.ux.action.start(chalk `Starting the ${toStart
            .map(name => chalk `{bold ${name}}`)
            .join(', ')} Docker container${toStart.length > 1 ? 's' : ''}`);
        try {
            await Promise.all(toStart.map(name => this.startDockerContainer(name)));
        }
        catch (error) {
            core_1.ux.action.stop('fail');
            if (error instanceof errors_1.CLIError) {
                throw new errors_1.CLIError(error.message +
                    `\n` +
                    `\nPlease make sure Docker is running, port ${port} is free on your` +
                    ` localhost, and you are using the latest StepZen CLI version.` +
                    `\nIf the issue persists contact support via the StepZen discord ` +
                    `channel (${constants_1.STEPZEN_DISCORD_URL}).`);
            }
            else {
                throw error;
            }
        }
        core_1.ux.action.stop('done');
        core_1.ux.action.start('Waiting for a StepZen service instance to start');
        const timeout = 30 * 1000; // 30 sec
        const { isHealthy, credentials } = await this.waitForStepZenToStart({
            port,
            timeoutMs: timeout,
        });
        if (!isHealthy || !credentials) {
            core_1.ux.action.stop(chalk.red('fail'));
            const logs = await this.getDockerContainerLogs({ ignoreErrors: true });
            await this.removeDockerContainers({ ignoreErrors: true });
            throw new errors_1.CLIError(`failed to start a StepZen service instance.` +
                `\nThe StepZen service instance has not reported healthy within ${timeout / 1000} seconds.` +
                (logs.stdout || logs.stderr
                    ? chalk `\n\nLogs from the {bold ${constants_1.STEPZEN_CONTAINER_NAME}} Docker container:`
                    : '') +
                (logs.stdout
                    ? `\n${chalk.dim((0, utils_1.prependEachLine)(logs.stdout, '[stdout] '))}\n`
                    : '') +
                (logs.stderr
                    ? `\n${chalk.dim((0, utils_1.prependEachLine)(logs.stderr, '[stderr] '))}\n`
                    : '') +
                `\nPlease make sure the StepZen metadata database details are correct,` +
                ` and you are using the latest StepZen CLI version.` +
                `\nIf the issue persists contact support via the StepZen discord ` +
                `channel (${constants_1.STEPZEN_DISCORD_URL}).`);
        }
        core_1.ux.action.stop('done');
        return {
            status: 'running',
            credentials,
        };
    }
    async stopDockerContainers() {
        try {
            const toStop = [constants_1.STEPZEN_CONTAINER_NAME];
            const dbStatus = await this.getDockerContainerStatus(constants_1.STEPZEN_AUTODB_CONTAINER_NAME);
            if (dbStatus === 'running') {
                toStop.push(constants_1.STEPZEN_AUTODB_CONTAINER_NAME);
            }
            core_1.ux.action.start(chalk `Stopping the ${toStop
                .map(name => chalk `{bold ${name}}`)
                .join(', ')} Docker container${toStop.length > 1 ? 's' : ''}`);
            await Promise.all(toStop.map(name => this.stopDockerContainer(name)));
        }
        catch (error) {
            core_1.ux.action.stop('fail');
            throw error;
        }
        core_1.ux.action.stop('done');
        return 'exited';
    }
    async stopDockerContainer(containerName) {
        const command = `docker container stop ${containerName}`;
        debug('stepzen:service')(chalk `running {cyan ${command}}`);
        const result = shell.exec(command, { silent: true });
        if (result.code !== 0) {
            throw new errors_1.CLIError(`failed to stop a StepZen Docker container.` +
                `\nCommand failed: ${command}` +
                `\n` +
                `\n${chalk.dim((0, utils_1.prependEachLine)(result.stderr, '[docker] '))}` +
                `\n` +
                `\nPlease make sure Docker is running, and you are using the` +
                ` latest StepZen CLI version.` +
                `\nIf the issue persists contact support via the StepZen discord ` +
                `channel (${constants_1.STEPZEN_DISCORD_URL}).`);
        }
        return 'exited';
    }
    async removeDockerContainers({ ignoreErrors, } = {}) {
        const status = await this.removeDockerContainer({
            containerName: constants_1.STEPZEN_CONTAINER_NAME,
            ignoreErrors,
        });
        return status;
    }
    async removeDockerContainer({ containerName, ignoreErrors, }) {
        const command = `docker container rm --force ${containerName}`;
        debug('stepzen:service')(chalk `running {cyan ${command}}`);
        core_1.ux.action.start(chalk `Removing the {bold ${containerName}} Docker container`);
        const result = shell.exec(command, { silent: true });
        if (result.code !== 0) {
            core_1.ux.action.stop(chalk.red('fail'));
            if (ignoreErrors) {
                return this.getDockerContainerStatus(containerName);
            }
            throw new errors_1.CLIError(`failed to remove a StepZen Docker container.` +
                `\nCommand failed: ${command}` +
                `\n` +
                `\n${chalk.dim((0, utils_1.prependEachLine)(result.stderr, '[docker] '))}` +
                `\n` +
                `\nPlease make sure Docker is running, and you are using the` +
                ` latest StepZen CLI version.` +
                `\nIf the issue persists contact support via the StepZen discord ` +
                `channel (${constants_1.STEPZEN_DISCORD_URL}).`);
        }
        core_1.ux.action.stop('done');
        return 'not-created';
    }
    async getDockerContainerLogs({ ignoreErrors, } = {}) {
        const command = `docker logs --tail 24 ${constants_1.STEPZEN_CONTAINER_NAME}`;
        debug('stepzen:service')(chalk `running {cyan ${command}}`);
        const result = shell.exec(command, { silent: true });
        if (result.code !== 0) {
            if (ignoreErrors) {
                debug('stepzen:service')(`failed to retrieve logs from the StepZen Docker container.` +
                    `\nCommand failed: ${command}` +
                    `\n` +
                    `\n${chalk.dim((0, utils_1.prependEachLine)(result.stderr, '[docker] '))}`);
                return {};
            }
            throw new errors_1.CLIError(`failed to retrieve logs from the StepZen Docker container.` +
                `\nCommand failed: ${command}` +
                `\n` +
                `\n${chalk.dim((0, utils_1.prependEachLine)(result.stderr, '[docker] '))}` +
                `\n` +
                `\nPlease make sure Docker is running, and you are using the` +
                ` latest StepZen CLI version.` +
                `\nIf the issue persists contact support via the StepZen discord ` +
                `channel (${constants_1.STEPZEN_DISCORD_URL}).`);
        }
        return {
            stdout: result.stdout,
            stderr: result.stderr,
        };
    }
    async execInDockerContainer(command) {
        const dockerCommand = `docker container exec ${constants_1.STEPZEN_CONTAINER_NAME} ${command}`;
        debug('stepzen:service')(chalk `running {cyan ${dockerCommand}}`);
        return shell.exec(dockerCommand, { silent: true });
    }
    async getDsnFromDockerContainer() {
        const command = `docker container inspect -f "{{json .Config.Env}}" ${constants_1.STEPZEN_CONTAINER_NAME}`;
        debug('stepzen:service')(chalk `running {cyan ${command}}`);
        const result = shell.exec(command, { silent: true });
        if (result.code !== 0) {
            const message = `Failed to get the metadata database details from the existing local StepZen image.` +
                `\nCommand failed: ${command}` +
                `\n` +
                `\n${chalk.dim((0, utils_1.prependEachLine)(result.stderr, '[docker] '))}`;
            debug('stepzen:service')(message + `\nreturning 'undefined', meaning 'no DSN found'`);
            return;
        }
        debug('stepzen:service')(`\t--> ${result.stdout}`);
        const env = JSON.parse(result.stdout);
        for (const envvar of env) {
            const [name, value] = envvar.split('=');
            if (name === 'STEPZEN_CONTROL_DB_DSN') {
                const dsn = value.trim();
                debug('stepzen:service')(`Found the STEPZEN_CONTROL_DB_DSN env var. Returning DSN = ${dsn}`);
                return dsn;
            }
        }
        const message = `Failed to get the metadata database details from the existing local StepZen image.` +
            `\nCould not find the 'STEPZEN_CONTROL_DB_DSN' variable in the image environment:` +
            `\n${env}`;
        debug('stepzen:service')(message + `\nreturning 'undefined', meaning 'no DSN found'`);
    }
    async printServiceStatusMessage(status) {
        switch (status) {
            case 'running': {
                this.log(chalk `Local StepZen service instance is running in the ` +
                    chalk `{bold ${constants_1.STEPZEN_CONTAINER_NAME}} Docker container`);
                let isLoggedIn;
                {
                    const [current, local] = await Promise.all([
                        (0, configuration_1.readConfiguration)(),
                        (0, configuration_1.readConfiguration)(constants_1.STEPZEN_LOCAL_CONFIG_FILE),
                    ]);
                    // disregard the uuid property for comparison
                    delete current.uuid;
                    delete local.uuid;
                    isLoggedIn = (0, lodash_1.isEqual)(current, local);
                    if (current.serviceInstance &&
                        'zenctl2' in current.serviceInstance &&
                        local.serviceInstance &&
                        'zenctl2' in local.serviceInstance) {
                        const currentPort = (0, url_helpers_1.getPortFromUrl)(current.serviceInstance.zenctl2);
                        const localPort = (0, url_helpers_1.getPortFromUrl)(local.serviceInstance.zenctl2);
                        if (currentPort !== localPort) {
                            this.warn(`You are currently logged in to a service instance on port` +
                                ` ${currentPort}. Please log in again to use port ${localPort}.`);
                        }
                    }
                }
                if (isLoggedIn) {
                    this.log(chalk ` - to use: {bold stepzen [command]}`);
                }
                else {
                    let localConfigPath = path.join(constants_1.STEPZEN_CONFIG_DIRECTORY, constants_1.STEPZEN_LOCAL_CONFIG_FILE);
                    if (process.platform !== 'win32') {
                        // On UNIX-like platforms a `~/.stepzen` format universally works in any shell
                        // On Windows it depends on the shell and looks much uglier.
                        //   - in cmd.exe it's %USERPROFILE%\.stepzen\stepzen-config.local.yaml
                        //   - in PowerShell it's $env:USERPROFILE\.stepzen\stepzen-config.local.yaml
                        //
                        // The output would look better with an absolute path, like
                        // C:\Users\sam\.stepzen\stepzen-config.local.yaml
                        localConfigPath = (0, utils_1.homeRelative)(localConfigPath);
                    }
                    this.log(chalk ` - to use: login with {bold {green stepzen login --config ${localConfigPath}}}` +
                        chalk ` then use normally with {bold stepzen [command]}`);
                }
                this.log(chalk ` - to stop: {bold stepzen service stop}`);
                break;
            }
            default:
                this.log(chalk `Local StepZen service instance is not running` +
                    chalk ` {dim (run {bold stepzen service start} to start)}`);
        }
    }
    async getStepZenHealthCheck(port) {
        const url = `http://127.0.0.1:${port}/healthz`;
        try {
            debug('stepzen:service')(chalk `fetching {cyan ${url}}`);
            const response = await (0, fetch_1.default)(url);
            debug('stepzen:service')(chalk `\t--> ${response.status}`);
            return response.status === 200;
        }
        catch (error) {
            debug('stepzen:service')(chalk `\t--> ${error}`);
            return false;
        }
    }
    async waitForStepZenToStart({ port, timeoutMs, }) {
        const waitingSince = new Date().getTime();
        let [status, isHealthy, credentials] = await Promise.all([
            this.getDockerContainerStatus(constants_1.STEPZEN_CONTAINER_NAME),
            this.getStepZenHealthCheck(port),
            this.getStepZenDefaultCredentials(),
        ]);
        while (status === 'running' &&
            !(isHealthy && credentials) &&
            new Date().getTime() - waitingSince < timeoutMs) {
            // eslint-disable-next-line no-await-in-loop
            await new Promise(resolve => setTimeout(resolve, 300));
            // eslint-disable-next-line no-await-in-loop
            const checks = await Promise.all([
                this.getDockerContainerStatus(constants_1.STEPZEN_CONTAINER_NAME),
                this.getStepZenHealthCheck(port),
                this.getStepZenDefaultCredentials(),
            ]);
            status = checks[0];
            isHealthy = checks[1];
            credentials = checks[2];
        }
        return { isHealthy, credentials };
    }
    async getStepZenDefaultCredentials() {
        const adminKeyResult = await this.execInDockerContainer('key admin');
        const apiKeyResult = await this.execInDockerContainer('key api');
        if (adminKeyResult.code !== 0 || apiKeyResult.code !== 0) {
            debug('stepzen:service')(chalk `Failed to retrieve the default account details because` +
                chalk ` {bold execInDockerContainer()} failed.`);
            return;
        }
        const adminKey = adminKeyResult.stdout.trim();
        const apiKey = apiKeyResult.stdout.trim();
        return adminKey && apiKey
            ? {
                deploymentType: 'local',
                account: 'graphql',
                adminKey,
                apiKeys: [apiKey],
            }
            : undefined;
    }
    async createLocalCredentialsFile({ port, credentials, }) {
        await (0, configuration_1.writeConfiguration)({
            account: credentials.account,
            adminkey: credentials.adminKey,
            apikey: credentials.apiKeys[0],
            serviceInstance: {
                deploymentType: credentials.deploymentType,
                zenctl2: `http://127.0.0.1:${port}/api/zenctl/__graphql`,
                introspection: `http://127.0.0.1:${port}/introspection/api/graphql`,
                dbintrospection: `http://127.0.0.1:${port}/dbintrospection/graphql`,
            },
        }, constants_1.STEPZEN_LOCAL_CONFIG_FILE);
    }
    validateProvidedDsn(flags) {
        if (!flags.dsn) {
            return undefined;
        }
        const parsed = (0, dsn_parser_1.parseDsn)(flags.dsn);
        if (parsed.success) {
            const value = parsed.value;
            if (value.db === undefined) {
                throw new errors_1.CLIError('DSN missing database');
            }
            if (value.user === undefined) {
                throw new errors_1.CLIError('DSN missing user');
            }
            if (value.pass === undefined) {
                throw new errors_1.CLIError('DSN missing password');
            }
            if ((0, url_helpers_1.isLocalhost)(value.host)) {
                value.host = 'host.docker.internal';
                return `${value.driver}://${value.user}:${value.pass}@${value.host}${(value.port && ':' + value.port) || ''}/${value.db}`;
            }
            return flags.dsn;
        }
        throw new errors_1.CLIError(parsed.message);
    }
}
exports.default = Service;
Service.description = 'Manage the local StepZen service instance (requires Docker).' +
    '\n' +
    'You can use a local StepZen service instance instead of the StepZen' +
    ' cloud to develop and test GraphQL endpoints locally. This way you can' +
    ' try StepZen out without giving the StepZen cloud access to your data' +
    ' sources and API endpoints.' +
    '\n\n' +
    'Local StepZen service instances are not suitable for production use.' +
    ' Please refer to the documentation at' +
    ' https://stepzen.com/docs/deployment/local-docker for more information' +
    ' and examples.';
Service.flags = {
    ...zen_command_1.default.flags,
    dsn: core_1.Flags.string({
        description: chalk `DSN of a StepZen metadata database, e.g.` +
            chalk ` {bold postgres://user:password@172.17.0.1:5432/zenctl}`,
        exclusive: ['reset-auto', 'prompt'],
    }),
    'reset-auto': core_1.Flags.boolean({
        description: 'Create fresh empty metadata database. Note: all existing endpoints will be deleted and you will be logged out.',
        exclusive: ['dsn', 'prompt'],
    }),
    prompt: core_1.Flags.boolean({
        description: 'Opens an interactive prompt to ask for database details (or fails, if running' +
            ' in a non-interactive mode).',
        exclusive: ['dsn', 'non-interactive'],
    }),
    port: core_1.Flags.integer({
        description: `Override the TCP port on which the local StepZen service instance will listen` +
            ` for connections (port ${DEFAULT_ZEN_PORT} by default).`,
    }),
};
Service.args = {
    action: core_1.Args.string({
        options: ['start', 'stop', 'upgrade'],
        required: false,
        description: chalk `
        \t{bold start}\tstart a local StepZen service instance in a Docker container
        \t\tThis command pulls the latest StepZen service instance Docker image so that the
        \t\tversion of StepZen you run locally is the same as the one running on
        \t\tstepzen.net.
        
        \t{bold stop}\tstop the local StepZen service instance (if running)
        \t\tThis command deletes the Docker container with the StepZen service instance,
        \t\tbut all your endpoints are persistently stored in the metadata database. They
        \t\tremain available when running {bold stepzen service start} next time.
        
        \t{bold upgrade}\tupgrade the local StepZen service instance if it is running
        \t\tThis command checks if a newer version of the StepZen service instance Docker
        \t\timage is available, and if it is then stops and deletes the currently running
        \t\tcontainer, pulls the latest image, and starts it. All endpoints are preserved.

        If no action is provided, print the service status and exit.`,
    }),
};
//# sourceMappingURL=service.js.map
"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
// This file contains the code for the `stepzen deploy` command.
const core_1 = require("@oclif/core");
const errors_1 = require("@oclif/core/lib/errors");
const chalk = require("chalk");
const fs = require("fs");
const path = require("path");
const prettyMilliseconds = require("pretty-ms");
const actions_1 = require("../shared/actions");
const configuration_1 = require("../shared/configuration");
const constants_1 = require("../shared/constants");
const stepzen_sdk_1 = require("../shared/stepzen-sdk");
const utils_1 = require("../shared/utils");
const zen_command_1 = require("../shared/zen-command");
const upload_1 = require("./upload");
class Deploy extends zen_command_1.default {
    // eslint-disable-next-line complexity
    async run() {
        const { args, flags } = await this.parse(Deploy);
        // validate the endpoint arg
        if (args.endpoint) {
            const maybeError = (0, utils_1.validateEndpoint)(args.endpoint);
            if (typeof maybeError === 'string') {
                throw new errors_1.CLIError(maybeError);
            }
        }
        // validate the --dir and --config flags
        const checkExists = (flag, kind) => {
            const value = flags[flag];
            if (value && !fs.existsSync(path.resolve(value))) {
                throw new errors_1.CLIError(chalk `${kind} does not exist: {bold --${flag} ${value}}` +
                    `\nPlease check that the path is correct and try again.`);
            }
        };
        checkExists('dir', 'directory');
        checkExists('config', 'file');
        const hasDeprecatedFlags = flags.schema || flags.configurationsets;
        let { configuration } = await this.ensureStepZenAccount({
            nonInteractive: flags['non-interactive'],
        });
        if (hasDeprecatedFlags && (0, stepzen_sdk_1.hasSdkInterfaceV2)(configuration)) {
            // zenctl2 does not support listing schemas and configuration sets
            const usedDeprecatedFlags = flags.schema && flags.configurationsets
                ? chalk `{bold --schema} and {bold --configurationsets} flags`
                : flags.schema
                    ? chalk `{bold --schema} flag`
                    : chalk `{bold --configurationsets} flag`;
            throw new errors_1.CLIError(chalk `{bold stepzen deploy} no longer supports the ${usedDeprecatedFlags}.` +
                chalk `\n\tSee more help with --help`);
        }
        // Print a deprecation warning (if necessary)
        if (hasDeprecatedFlags && !flags.silent) {
            const messages = ['schema', 'configurationsets']
                .map(flag => {
                if (flags[flag]) {
                    return chalk `{yellow the {bold ${flag}} flag is deprecated and will be removed in future versions}`;
                }
                return '';
            })
                .filter(Boolean);
            messages[messages.length - 1] += chalk `\n\tSee more help with --help`;
            messages.forEach(message => this.warn(message));
            this.log();
        }
        // Enforce the "required" flag on `schema` for the deprecated code path
        // (this was done by oclif when `schema` was marked as `required`)
        if (hasDeprecatedFlags && !flags.schema) {
            throw new errors_1.CLIError(chalk `When using {bold --configurationsets}, the {bold --schema} flag is required:` +
                chalk `\n\t--schema SCHEMA  {dim name of a schema uploaded earlier with {bold stepzen upload}}` +
                chalk `\n\tSee more help with --help`);
        }
        // Enforce the "required" flag on `endpoint` for the deprecated code path
        // (this was done by oclif when `endpoint` arg was marked as `required`)
        if (hasDeprecatedFlags && !args.endpoint) {
            throw new errors_1.CLIError(chalk `When using {bold --schema}, the {bold endpoint} argument is required:` +
                chalk `\n\tendpoint  {dim name of the endpoint (e.g. {bold api/customers})}` +
                chalk `\n\tSee more help with --help`);
        }
        const deployStart = new Date().getTime();
        let result;
        if (hasDeprecatedFlags) {
            const endpoint = args.endpoint;
            if (!flags.silent) {
                core_1.ux.action.start(`Deploying ${chalk.yellow(endpoint)} to StepZen`);
            }
            try {
                result = await this.doDeployV1WithSdkV1({
                    endpoint,
                    schema: flags.schema,
                    configurationsets: flags.configurationsets,
                    configuration,
                });
            }
            catch (error2) {
                if (!flags.silent) {
                    core_1.ux.action.stop(chalk.red('fail'));
                }
                throw error2;
            }
        } /* no deprecated flags */
        else {
            const workspace = await this.ensureStepZenWorkspace({
                directory: flags.dir,
                nonInteractive: true,
                silent: flags.silent,
            });
            const endpoint = args.endpoint || workspace.endpoint;
            if (!flags.silent) {
                core_1.ux.action.start(`Deploying ${chalk.yellow(endpoint)} to StepZen`);
            }
            let configPath;
            if (flags.config) {
                configPath = path.resolve(flags.config);
            }
            else {
                const defaultConfigPath = path.join(workspace.schema, 'config.yaml');
                if (fs.existsSync(defaultConfigPath)) {
                    configPath = defaultConfigPath;
                }
            }
            if (configPath && fs.statSync(configPath).size === 0) {
                configPath = undefined;
            }
            try {
                const res = await (0, stepzen_sdk_1.tryZenCtl2ThenZenCtl1)(configuration, stepzen => {
                    if (stepzen.version === 'v2') {
                        return this.doDeployV2WithSdkV2({
                            endpoint,
                            workspace,
                            endpointConfig: configPath,
                            stepzen,
                            configuration,
                        });
                    }
                    return this.doDeployV2WithSdkV1({
                        endpoint,
                        workspace,
                        endpointConfig: configPath,
                        configuration,
                    });
                });
                if (res.configMigrated) {
                    // eslint-disable-next-line require-atomic-updates
                    configuration = res.configuration;
                    await (0, configuration_1.writeCredentialsAndServiceToConfigFile)(configuration, res.configuration.serviceInstance);
                }
                result = res.result;
            }
            catch (error2) {
                if (!flags.silent) {
                    core_1.ux.action.stop(chalk.red('fail'));
                }
                throw error2;
            }
        }
        const { endpoint, response: { data, error }, } = result;
        if (data) {
            if (!flags.silent) {
                const deployEnd = new Date().getTime();
                const deployTime = deployEnd - deployStart;
                core_1.ux.action.stop(`${chalk.grey('done in')} ${prettyMilliseconds(deployTime)} ðŸš€`);
                console.log((0, utils_1.formatEndpointInfo)({ configuration, endpoint }));
            }
        }
        else {
            if (!flags.silent) {
                core_1.ux.action.stop(chalk.red('fail'));
            }
            // Errors. Exit, and output the server's error response
            throw new errors_1.CLIError(error?.message || 'An error occurred.');
        }
    }
    async doDeployV1WithSdkV1({ endpoint, schema, configurationsets, configuration, }) {
        // If this is a public account, add a special configuration set to make the
        // endpoint public (https://github.com/steprz/zen/pull/5701)
        if (configuration.account.startsWith('public')) {
            configurationsets = configurationsets
                ? `${configurationsets},stepzen/public`
                : 'stepzen/public';
        }
        const response = await (0, actions_1.deploy)(endpoint, configurationsets, schema);
        return {
            endpoint,
            response: {
                data: response.success ? response.message : undefined,
                error: response.success
                    ? undefined
                    : { message: JSON.stringify(response.errors) },
            },
        };
    }
    async doDeployV2WithSdkV1({ endpoint, workspace, endpointConfig, configuration, }) {
        const schema = endpoint;
        let configurationsets;
        if (endpointConfig) {
            await upload_1.default.run([
                'configurationset',
                endpoint,
                '--file',
                endpointConfig,
                '--silent',
            ]);
            configurationsets = endpoint;
        }
        await upload_1.default.run([
            'schema',
            endpoint,
            '--dir',
            workspace.schema,
            '--silent',
        ]);
        return this.doDeployV1WithSdkV1({
            endpoint,
            schema,
            configurationsets,
            configuration,
        });
    }
    async doDeployV2WithSdkV2({ endpoint, workspace, endpointConfig, configuration, stepzen, }) {
        // already validated to include a `/`
        const idx = endpoint.indexOf('/');
        const folder = endpoint.slice(0, idx);
        const name = endpoint.slice(idx + 1);
        // If this is a public account, add a special configuration set to make the
        // endpoint public (https://github.com/steprz/zen/pull/5701)
        const isPublic = configuration.account.startsWith('public');
        const client = await stepzen.client({
            account: configuration.account,
            adminKey: configuration.adminkey,
            deploymentType: (0, constants_1.getDeploymentType)(configuration),
        });
        const response = await client.deploy({
            folder,
            name,
            directory: workspace.schema,
            config: endpointConfig,
            public: isPublic,
        });
        if (response.error) {
            if (response.error.message.includes('Variable "$configuration" got invalid value')) {
                // - use the terms familiar to CLI users
                // - avoid dumping the `config.yaml` content into the stdout as it typically contains keys
                response.error.message = response.error.message.replace(/^Variable "\$configuration" got invalid value.*/i, chalk `the {bold config.yaml} file does not pass validation.` +
                    ` Please fix the issues and try again.`);
            }
            if (response.error.message.includes('ruleset is invalid:')) {
                // - use the terms familiar to CLI users
                response.error.message = response.error.message.replace(/^ruleset is invalid:/i, chalk `the {bold config.yaml} file does not pass validation.` +
                    ` Please fix the issues and try again.` +
                    `\nIn field "ruleset":`);
            }
        }
        return { endpoint, response };
    }
}
exports.default = Deploy;
Deploy.description = 'Deploy to StepZen.';
Deploy.usage = `deploy [ENDPOINT] [--config=path/to/config.yaml] [--dir=path/to/workspace]

-- OR (deprecated) --

$ stepzen deploy ENDPOINT --schema=schema [--configurationsets=cs1[,cs2[,..]]]`;
Deploy.flags = {
    ...zen_command_1.default.flags,
    dir: core_1.Flags.string({ description: 'Working directory' }),
    silent: core_1.Flags.boolean(),
    // configurationsets is assumed to be a comma separated string naming uploaded configurationsets
    // a special configuration 'stepzen/defaults' is recognized.
    configurationsets: core_1.Flags.string({
        description: chalk `
        Name(s) of configuration sets uploaded earlier with {bold stepzen upload}` +
            chalk `
        {yellow [DEPRECATED: this flag will be removed in future versions]}
        
        Instead, please use one of these options:
        - {bold stepzen deploy} (without the {bold --configurationsets} flag)
        \tto use the configuration from the {bold config.yaml} file in the current directory (if exists)
        - {bold stepzen deploy --config path/to/config.yaml}
        \tto explicitly specify the configuration file`,
        exclusive: ['config', 'dir'],
    }),
    config: core_1.Flags.string({
        helpValue: 'path/to/config.yaml',
        description: '[default: config.yaml] Configuration file to use (relative to the current directory)',
    }),
    schema: core_1.Flags.string({
        description: chalk `
        Name of a schema uploaded earlier with {bold stepzen upload}` +
            chalk `
        {yellow [DEPRECATED: this flag will be removed in future versions]}
        
        Instead, please use one of these options:
         - {bold stepzen deploy} (without the {bold --schema} flag)
        \tto deploy the schema from a StepZen workspace in your current directory
         - {bold stepzen deploy --dir path/to/workspace}
        \tto deploy from a StepZen workspace in another folder`,
        exclusive: ['config', 'dir'],
    }),
};
Deploy.args = {
    endpoint: core_1.Args.string({
        description: chalk `name of the endpoint (e.g. {bold api/customers})
        [default: use the {underline endpoint} property from stepzen.config.json]`,
        required: false,
    }),
};
//# sourceMappingURL=deploy.js.map
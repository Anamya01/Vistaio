type ParsedDsn = {
    driver: string;
    host: string;
    user?: string;
    pass?: string;
    port?: number;
    db?: string;
    /** Query params */
    params?: Record<string, number | string | boolean>;
};
type ParseDsnOptions = {
    /** Whether to lowercase parsed driver name, default: false */
    lowercaseDriver?: boolean;
    /** Overrides parsed values by those one (except query params) */
    overrides?: Omit<Partial<ParsedDsn>, 'params'>;
};
declare const errorReasons: {
    readonly EMPTY_DSN: "DSN cannot be empty";
    readonly INVALID_ARGUMENT: "DSN must be a string";
    readonly PARSE_ERROR: "Cannot parse DSN";
    readonly INVALID_PORT: "Invalid port";
};
type ErrorReasons = keyof typeof errorReasons;
type ParserSuccessResult = {
    success: true;
    value: ParsedDsn;
};
type ParserErrorResult = {
    success: false;
    reason: ErrorReasons;
    message: string;
};
type ParserResult = ParserSuccessResult | ParserErrorResult;
type ParsableDsn = string;

declare const parseDsn: (dsn: unknown, options?: ParseDsnOptions) => ParserResult;

declare const parseDsnOrThrow: (dsn: unknown, options?: ParseDsnOptions & {
    errorMsgPrefix?: string;
}) => ParsedDsn;

/**
 * @throws Error when not parsable
 */
declare const assertParsableDsn: (dsn: unknown, msg?: string) => asserts dsn is string;

declare const isParsableDsn: (dsn: unknown) => dsn is string;

export { ParsableDsn, ParseDsnOptions, ParsedDsn, assertParsableDsn, isParsableDsn, parseDsn, parseDsnOrThrow };

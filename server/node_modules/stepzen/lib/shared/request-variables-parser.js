"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRequestVariables = exports.parseVariableValue = void 0;
const chalk = require("chalk");
const debug = require("debug");
const unNonNull = (type) => type.kind === 'NonNullType' ? type.type : type;
const parseVariableValue = (value, typename) => {
    switch (typename) {
        case 'Int': {
            const parsed = parseInt(value, 10);
            if (!Number.isNaN(parsed)) {
                return { result: parsed };
            }
            break;
        }
        case 'Float': {
            const parsed = parseFloat(value);
            if (!Number.isNaN(parsed) && Number.isFinite(parsed)) {
                return { result: parsed };
            }
            break;
        }
        case 'Boolean':
            if (value === 'true') {
                return { result: true };
            }
            if (value === 'false') {
                return { result: false };
            }
            break;
        case 'String':
        case 'ID':
        case 'Date':
        case 'DateTime':
        case 'Secret':
            return { result: value };
        case 'JSON':
        default:
            try {
                const parsed = JSON.parse(value);
                return { result: parsed };
            }
            catch (error) {
                debug('stepzen:request')(`JSON parsing error while parsing the value ${value}: `, error);
            }
    }
    return {
        error: {
            message: chalk `{italic ${value}} is not a valid {bold ${typename}}.`,
        },
    };
};
exports.parseVariableValue = parseVariableValue;
const parseRequestVariables = (variableFlags, operation, varFile = {}) => {
    // errors for duplicate vars
    const errors = [];
    const rawVarValues = new Map();
    for (const variable of variableFlags || []) {
        const idx = variable.indexOf('=');
        if (idx < 0) {
            errors.push(chalk `Invalid format for the variable {bold ${variable}}.` +
                chalk ` Please provide a value with {bold --var ${variable}={underline value}}`);
            continue;
        }
        const name = variable.substring(0, idx);
        const value = variable.substring(idx + 1);
        if (rawVarValues.has(name)) {
            errors.push(chalk `Duplicate value for the variable {bold ${name}}.` +
                chalk ` Please keep only one {bold --var} flag for the {bold ${name}} variable.`);
            continue;
        }
        rawVarValues.set(name, value);
    }
    const variables = {};
    for (const varDef of operation.variableDefinitions ?? []) {
        const name = varDef.variable.name.value;
        const rawValue = rawVarValues.get(name);
        rawVarValues.delete(name);
        if (rawValue === undefined && varFile[name] === undefined) {
            // errors for missing required vars
            if (varDef.type.kind === 'NonNullType') {
                errors.push(chalk `Missing value for a required variable {bold ${name}}. Please` +
                    chalk ` pass it with a {bold --var ${name}={underline value}} or` +
                    chalk ` {bold --var-file={underline file}} flag.`);
            }
            continue;
        }
        if (rawValue === undefined) {
            variables[name] = varFile[name];
        }
        else {
            const unNonNullType = unNonNull(varDef.type);
            const isList = unNonNullType.kind === 'ListType';
            const { result, error } = (0, exports.parseVariableValue)(rawValue, isList
                ? 'JSON' // parse any list as a JSON value
                : unNonNullType.name.value);
            // errors for invalid values
            if (error) {
                errors.push(chalk `Invalid value for the variable {bold ${name}}: ` +
                    error.message);
                continue;
            }
            variables[name] = result;
        }
    }
    // errors for extra vars
    for (const name of rawVarValues.keys()) {
        errors.push(chalk `Unused variable {bold ${name}}. Please remove it.`);
    }
    return { variables, errors };
};
exports.parseRequestVariables = parseRequestVariables;
//# sourceMappingURL=request-variables-parser.js.map
"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateConfigurationPayload = exports.generateSchemaFilesPayload = exports.generateZipPayload = exports.generateYamlPayload = void 0;
// This file contains helpers that zip a file or directory
const archiver = require("archiver");
const debug = require("debug");
const FormData = require("form-data");
const fs = require("fs");
const glob = require("glob");
const os = require("os");
const path = require("path");
const yaml = require("yaml");
const transpiling_1 = require("./transpiling");
const validation_1 = require("./validation");
const rmtemp_1 = require("./rmtemp");
// This function takes a (yaml) file path
// and creates a FormData payload, containing the yaml content as 'yaml'
const generateYamlPayload = async (file) => {
    return new Promise((resolve, reject) => {
        const payload = new FormData();
        if (file) {
            if (!fs.existsSync(file)) {
                reject(new Error(`File does not exist: ${file}`));
            }
            const content = fs.readFileSync(file, 'utf8');
            debug('stepzen:sdk:payload')(`adding YAML payload\n${content}`);
            payload.append('yaml', fs.readFileSync(file));
            resolve(payload);
        }
        else {
            reject(new Error('File not specified'));
        }
    });
};
exports.generateYamlPayload = generateYamlPayload;
// This function takes a directory path, and optional data object,
// and creates a FormData payload, containing the directory contents as 'zip',
// and any other items in the data object.
const generateZipPayload = async (directory, data, filters) => {
    return new Promise((resolve, reject) => {
        const payload = new FormData();
        if (data) {
            for (const [key, value] of Object.entries(data)) {
                payload.append(key, value);
            }
        }
        // Store it in /tmp. Create a WriteStream
        const filepath = path.join(os.tmpdir(), `stepzen-payload-${Date.now()}.zip`);
        const output = fs.createWriteStream(filepath, { mode: 0o600 });
        // We're making a zip file
        const archive = archiver('zip', {
            zlib: { level: 9 },
        });
        archive.on('error', error => {
            fs.unlinkSync(filepath);
            reject(error);
        });
        // We're piping it to the WriteStream
        archive.pipe(output);
        // If we've specified a directory, add it to the archive
        if (directory) {
            if (!fs.existsSync(directory)) {
                reject(new Error(`Directory does not exist: ${directory}`));
            }
            // Get all the files in the directory (and all subdirectories).
            const allFiles = glob.sync('**', { cwd: directory });
            // Loop through each file, because we want to filter them
            // We add them manually, because when we use glob, it embeds
            // a full path, and we want everything to explicitly
            // start at the root of the archive.
            allFiles.forEach(file => {
                const include = filters.some(filter => file.match(filter));
                if (include) {
                    debug('stepzen:archive')(file);
                    archive.file(path.join(directory, file), { name: file });
                }
            });
        }
        // Once we're done, append a ReadStream to the tmp file
        output.on('close', () => {
            const stream = fs.createReadStream(filepath);
            payload.append('zip', stream);
            // Remove the temporary zip
            stream.on('close', () => {
                fs.unlinkSync(filepath);
            });
            // This is where we return the payload
            resolve(payload);
        });
        // Archive the file or directory
        archive.finalize();
    });
};
exports.generateZipPayload = generateZipPayload;
const generateSchemaFilesPayload = (workspaceFolderPath) => {
    if (!fs.existsSync(workspaceFolderPath)) {
        throw new Error(`Failed to read folder ${workspaceFolderPath}. Does it exist?`);
    }
    const files = glob
        .sync('**/*.graphql', { cwd: workspaceFolderPath })
        .map(file => {
        return {
            name: file,
            content: fs.readFileSync(`${workspaceFolderPath}/${file}`, 'utf8'),
        };
    });
    if (files.length === 0) {
        throw new Error(`Failed to find any .graphql files in ${workspaceFolderPath}`);
    }
    return {
        files,
        entryPoint: 'index.graphql',
    };
};
exports.generateSchemaFilesPayload = generateSchemaFilesPayload;
const generateConfigurationPayload = async (configFilePath) => {
    if (!configFilePath) {
        return null;
    }
    await (0, validation_1.validateConfigurationset)(configFilePath);
    const transpiled = await (0, transpiling_1.transpileConfigurationset)(configFilePath);
    try {
        debug('stepzen:sdk')(`effective config written to ${transpiled}`);
        const content = fs.readFileSync(transpiled, 'utf-8');
        return yaml.parse(content, { schema: 'failsafe' }) || null;
    }
    finally {
        (0, rmtemp_1.rmtemp)(path.dirname(transpiled));
    }
};
exports.generateConfigurationPayload = generateConfigurationPayload;
//# sourceMappingURL=payloads.js.map
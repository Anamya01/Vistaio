"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServiceInstanceForDomain = void 0;
// This file contains the code for the `stepzen login` command.
// Stepzen login checks that credentials presented are good and
// subsequently changes the identity of the logged in account.
const core_1 = require("@oclif/core");
const errors_1 = require("@oclif/core/lib/errors");
const chalk = require("chalk");
const debug = require("debug");
const configuration_1 = require("../shared/configuration");
const constants_1 = require("../shared/constants");
const stepzen_sdk_1 = require("../shared/stepzen-sdk");
const url_helpers_1 = require("../shared/url-helpers");
const utils_1 = require("../shared/utils");
const zen_command_1 = require("../shared/zen-command");
// If the `--config` file defines a custom service instance, the `login`
// command should authenticate against the ZenCtl2 API of _that_ service
// instance regardless of the `STEPZEN_ZENCTL_API_URL` env. variable.
//
// If the `--config` file does not define a custom service instance,
// the `login` command should follow the same logic as all other commands,
// i.e. try to use the ZenCtl2 API of the default service instance first,
// and if that fails, fallback to its ZenCtl1 API.
// In this case API endpoints are defined in the usual way:
//  1. the env. vars
//  2. the existing config file (this step would be a no-op for `login`)
//  3. the default.
async function tryCustomZenCtl2ThenDefaultZenCtl2ThenDefaultZenCtl1(configuration, fn) {
    if (configuration.serviceInstance &&
        'zenctl2' in configuration.serviceInstance) {
        // Not using `getDeploymentType(configuration)` here to prefer the value
        // from the configuration object over the `STEPZEN_DEPLOYMENT_TYPE` env var.
        const deploymentType = configuration.serviceInstance.deploymentType ||
            process.env.STEPZEN_DEPLOYMENT_TYPE ||
            constants_1.DEFAULT_STEPZEN_DEPLOYMENT_TYPE;
        const stepzen2 = (0, stepzen_sdk_1.getStepzen2SDK)(configuration.serviceInstance.zenctl2, deploymentType);
        return {
            result: await fn(stepzen2),
            serviceInstance: configuration.serviceInstance,
        };
    }
    return (0, stepzen_sdk_1.tryZenCtl2ThenZenCtl1)(configuration, fn);
}
const getServiceInstanceForDomain = (domainOrUrl) => {
    if (domainOrUrl === undefined) {
        return { result: undefined };
    }
    // Test with a regex first because `new URL('localhost:9000')` succeeds and
    // considers `localhost:` to be a scheme, and `9000` to be a hostname, which
    // is not expected here.
    let port;
    const HOST_AND_PORT_REGEX = /^(?<hostname>[a-z0-9\-._~%]+|\[[a-f0-9:.]+\]):(?<port>\d+)$/i;
    const match = HOST_AND_PORT_REGEX.exec(domainOrUrl);
    if (match && match.groups?.hostname && match.groups?.port) {
        port = match.groups.port;
        domainOrUrl = match.groups.hostname;
    }
    let url;
    try {
        url = new URL(domainOrUrl);
        if (url.pathname === '/') {
            url.pathname = constants_1.ZENCTL2_URL;
        }
    }
    catch {
        const zenctl2 = `http${(0, url_helpers_1.isLocalhost)(domainOrUrl) ? '' : 's'}://${domainOrUrl}${port ? `:${port}` : ''}${constants_1.ZENCTL2_URL}`;
        // ensure the inferred zenctl2 URL is valid
        try {
            url = new URL(zenctl2);
        }
        catch (error) {
            debug('stepzen:login')(`the inferred zenctl2 URL is invalid: ${zenctl2}`);
            return {
                error: {
                    message: error.message || 'Invalid URL',
                },
            };
        }
    }
    // special case since [account.]stepzen.net is the default
    if (url.hostname.match(/^([A-Za-z0-9]+\.)?stepzen\.net$/)) {
        return { result: undefined };
    }
    // special case since [account.]steprz.net uses ZenCtl v1 (and is the default)
    // disallow x.steprz.net but do allow us.ibm.steprz.net
    if (url.hostname.match(/^([A-Za-z0-9]+\.)?steprz\.net$/)) {
        return {
            error: {
                message: chalk `Not currently supported - {bold stepzen login steprz.net}` +
                    chalk ` requires {bold steprz.net} to use ZenCtl v2.`,
            },
        };
    }
    // ZenCtl v2 endpoint is deployed to the `stepzen` account
    if (!(0, url_helpers_1.isLocalhost)(url) && url.hostname.includes('.')) {
        url.hostname = `stepzen.${url.hostname}`;
    }
    debug('stepzen:login')(`using zenctl2 URL ${url}`);
    return {
        result: {
            deploymentType: 'local',
            zenctl2: url.href,
        },
    };
};
exports.getServiceInstanceForDomain = getServiceInstanceForDomain;
class Login extends zen_command_1.default {
    async run() {
        const { flags, args } = await this.parse(Login);
        if (flags.public && args.domain) {
            throw new errors_1.CLIError(chalk `Public accounts are only supported in the {bold stepzen.net} StepZen service instance.` +
                chalk ` Please remove either {bold --public} or {bold ${args.domain}}.`);
        }
        const { result: claimedServiceInstance, error } = (0, exports.getServiceInstanceForDomain)(args.domain);
        if (error) {
            const message = error.message === 'Invalid URL'
                ? chalk `Could not parse {bold ${args.domain}} as a StepZen service` +
                    chalk ` instance domain name or URL. Please make sure it's correct.`
                : error.message;
            throw new errors_1.CLIError(message);
        }
        const initialConfig = await (0, configuration_1.readConfiguration)();
        let claimedConfig = {
            uuid: initialConfig.uuid,
            account: undefined,
            adminkey: undefined,
            serviceInstance: claimedServiceInstance,
        };
        if (flags.config) {
            // If the --config flag is provided, try and log in using the credentials
            // and the service instance in the file.
            const referenceConfig = await (0, configuration_1.importConfiguration)(flags.config);
            claimedConfig = {
                ...claimedConfig,
                account: referenceConfig.account,
                adminkey: referenceConfig.adminkey,
                serviceInstance: claimedConfig.serviceInstance
                    ? {
                        ...claimedConfig.serviceInstance,
                        ...referenceConfig.serviceInstance,
                    }
                    : referenceConfig.serviceInstance,
            };
        }
        let loggedInConfig;
        if (flags.public) {
            loggedInConfig =
                await tryCustomZenCtl2ThenDefaultZenCtl2ThenDefaultZenCtl1(claimedConfig, stepzen => stepzen.createAnonymousAccount(claimedConfig.uuid));
        }
        else {
            // Check if the --account flag is provided, and if not prompt the user for an account name
            if (!claimedConfig.account) {
                // eslint-disable-next-line require-atomic-updates
                claimedConfig.account =
                    flags.account || (await core_1.ux.prompt('What is your account name?'));
            }
            // Check if the --adminkey flag is provided, and if not prompt the user for an admin key.
            if (!claimedConfig.adminkey) {
                // eslint-disable-next-line require-atomic-updates
                claimedConfig.adminkey =
                    flags.adminkey === undefined
                        ? await core_1.ux.prompt('What is your admin key?', {
                            required: false,
                            type: 'hide',
                        })
                        : flags.adminkey;
            }
            loggedInConfig =
                await tryCustomZenCtl2ThenDefaultZenCtl2ThenDefaultZenCtl1(claimedConfig, stepzen => stepzen.login(claimedConfig.adminkey, claimedConfig.account));
        }
        const { result: credentials, serviceInstance } = loggedInConfig;
        if (serviceInstance) {
            if (flags.introspection) {
                // a custom introspection URL was passed: probe it and display an informative
                // failure message
                let introspectionBaseUrl = flags.introspection;
                if (!introspectionBaseUrl.match(/^https?:/)) {
                    introspectionBaseUrl = `https://${introspectionBaseUrl}`;
                }
                try {
                    await (0, utils_1.probeEndpoint)((0, url_helpers_1.appendPathnameIfEmpty)(introspectionBaseUrl, constants_1.INTROSPECTION_URL_PATH), 1);
                    await (0, utils_1.probeEndpoint)((0, url_helpers_1.appendPathnameIfEmpty)(introspectionBaseUrl, constants_1.DBINTROSPECTION_URL_PATH), 1);
                    serviceInstance.introspection = introspectionBaseUrl;
                    serviceInstance.dbintrospection = introspectionBaseUrl;
                    this.log(chalk `Using the introspection service at {bold ${introspectionBaseUrl}}.`);
                }
                catch (error2) {
                    this.error(`Unable to connect to introspection endpoint ${introspectionBaseUrl}, aborting`);
                }
            }
            else {
                this.log('Using the default StepZen introspection service.');
            }
            await (0, configuration_1.writeCredentialsAndServiceToConfigFile)(credentials, serviceInstance);
        }
        else {
            // If the new service instance is 'undefined', explicitly remove any
            // service instance details that may be stored in the config file.
            await (0, configuration_1.removeCredentialsAndServiceFromConfigFile)();
            // This call alone won't remove the service instance from config file
            await (0, configuration_1.writeCredentialsAndServiceToConfigFile)(credentials);
        }
        const host = serviceInstance
            ? new URL(serviceInstance.zenctl2).host.replace(/^stepzen\./, '')
            : 'stepzen.net';
        const toInstanceMsg = host.endsWith('stepzen.net')
            ? ''
            : chalk ` to {bold ${host}}`;
        this.log(`You have successfully logged in${toInstanceMsg} with the` +
            chalk ` {bold ${credentials.account}} account.`);
    }
}
exports.default = Login;
Login.description = 'Log in to StepZen.';
Login.flags = {
    ...zen_command_1.default.flags,
    account: core_1.Flags.string({
        char: 'a',
        description: 'StepZen account name (copy from https://stepzen.com/account).' +
            ' If not provided, the CLI prompts the users to enter one.',
        exclusive: ['config', 'public'],
    }),
    adminkey: core_1.Flags.string({
        char: 'k',
        description: 'Admin key (copy from https://stepzen.com/account)' +
            ' If not provided, the CLI prompts the users to enter one.',
        exclusive: ['config', 'public'],
    }),
    public: core_1.Flags.boolean({
        description: 'Create a public anonymous StepZen account and use it. This is handy' +
            ' for trying StepZen out, but it not suitable for handling private' +
            ' data as all endpoints created with a public account will be public.',
        exclusive: ['config', 'account', 'adminkey'],
    }),
    introspection: core_1.Flags.string({
        description: chalk `Override the default StepZen introspection service URL for all {bold stepzen import} commands. ` +
            chalk `If not provided, use the default introspection URL.` +
            `\n` +
            `\nExample:` +
            `\nstepzen login --introspection stepzen-introspection.mydomain.com`,
    }),
    config: core_1.Flags.string({
        exclusive: ['account', 'adminkey', 'public'],
        hidden: true,
    }),
};
Login.args = {
    domain: core_1.Args.string({
        required: false,
        description: chalk `Domain of the StepZen service to login to (e.g.` +
            chalk ` {bold stepzen.acme.com}). If no domain is provided,` +
            chalk ` {bold stepzen.net} is used by default.`,
    }),
};
//# sourceMappingURL=login.js.map
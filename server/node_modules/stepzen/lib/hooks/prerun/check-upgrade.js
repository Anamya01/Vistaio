"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeCheckForUpdates = exports.checkForDockerUpdate = exports.checkForNpmUpdate = exports.shouldCheckForUpdates = exports.compareMajorVersions = void 0;
const chalk = require("chalk");
const compare_versions_1 = require("compare-versions");
const fsx = require("fs-extra");
const debug_1 = require("debug");
const core_1 = require("@oclif/core");
const fetch_1 = require("@stepzen/fetch");
const constants_1 = require("../../shared/constants");
const errors_1 = require("../../shared/errors");
const docker_1 = require("../../shared/docker");
const majorRegexp = /\d+\./;
const timeoutBeta = 1000 * 60 * 60 * 24; // one day
const timeoutStable = 7 * timeoutBeta; // one week
const compareMajorVersions = (v1, v2) => {
    const v1Major = v1.match(majorRegexp);
    const v2Major = v2.match(majorRegexp);
    if (!v1Major || !v2Major) {
        return ('Cannot get the major from the version string ' +
            `'${v1Major ? v2 : v1}'. Does it follow semver?`);
    }
    return parseInt(v1Major[0], 10) - parseInt(v2Major[0], 10);
};
exports.compareMajorVersions = compareMajorVersions;
const shouldCheckForUpdates = (version) => {
    if (!fsx.existsSync(constants_1.STEPZEN_LAST_UPDATE_CHECK_TIMESTAMP)) {
        // always check for a new version if the file does not exist
        return true;
    }
    const { mtime } = fsx.statSync(constants_1.STEPZEN_LAST_UPDATE_CHECK_TIMESTAMP);
    const threshold = version.includes('beta') ? timeoutBeta : timeoutStable;
    return new Date().getTime() - mtime.getTime() > threshold;
};
exports.shouldCheckForUpdates = shouldCheckForUpdates;
const checkForNpmUpdate = async (version) => {
    let versions;
    try {
        const pkgmeta = await (0, fetch_1.default)('https://registry.npmjs.org/stepzen').then(r => r.json());
        versions = pkgmeta['dist-tags'];
    }
    catch (error) {
        // cannot connect to npm -> proceed
        (0, debug_1.default)('stepzen:check-upgrade')('failed to get the stepzen version info from npm', error);
        return { message: undefined, isBlocking: false, failed: true };
    }
    let beta = false;
    let latest = versions.latest;
    const result = {
        message: undefined,
        isBlocking: false,
        failed: false,
    };
    if (version.includes('beta')) {
        beta = true;
        latest = versions.beta;
    }
    const upgradeable = (0, compare_versions_1.compareVersions)(version, latest);
    if (upgradeable === -1) {
        const diff = `${chalk.grey(version)} => ${latest}`;
        if (beta) {
            result.message = `${chalk.yellow('An upgrade to the beta channel is available:')}
${diff}
${chalk.green('npm install -g stepzen@beta')}
      `;
        }
        else {
            result.message = `${chalk.yellow('An upgrade to StepZen CLI is available:')}
${diff}
${chalk.green('npm install -g stepzen')}
      `;
        }
        const versionCmpLatest = (0, exports.compareMajorVersions)(version, latest);
        if (typeof versionCmpLatest === 'string') {
            (0, debug_1.default)('stepzen:check-upgrade')(versionCmpLatest);
            result.message = errors_1.UPGRADE_CHECK_ERROR;
            result.isBlocking = true;
            result.failed = true;
        }
        else {
            result.isBlocking = versionCmpLatest < 0;
        }
    }
    return result;
};
exports.checkForNpmUpdate = checkForNpmUpdate;
const checkForDockerUpdate = async () => {
    const { result: versions, error } = await (0, docker_1.getDockerImageVersions)();
    if (error) {
        // ignore any errors
        (0, debug_1.default)('stepzen:check-upgrade')(`Failed to get the local / latest Docker image versions. ${error.message}`);
        return { message: undefined, isBlocking: false };
    }
    if (versions.latest !== versions.local) {
        (0, debug_1.default)('stepzen:check-upgrade')(`Detected a diff between the local and the latest Docker image versions:` +
            `\n\tlocal: ${versions.local}` +
            `\n\tlatest: ${versions.latest}`);
        return {
            message: chalk `{yellow A new version of the StepZen service image is available.}` +
                chalk `\n{yellow Please run {green {bold stepzen service upgrade}} to upgrade.}`,
            isBlocking: false,
        };
    }
    (0, debug_1.default)('stepzen:check-upgrade')(`The local and the latest Docker image versions are the same`);
    return { message: undefined, isBlocking: false };
};
exports.checkForDockerUpdate = checkForDockerUpdate;
const maybeCheckForUpdates = async ({ version, command, args, }) => {
    const noop = {
        message: undefined,
        isBlocking: false,
    };
    if (!(0, exports.shouldCheckForUpdates)(version)) {
        return noop;
    }
    const shouldSkipDockerUpgradeCheck = command === 'service' &&
        (args.action === 'stop' || args.action === 'upgrade');
    const [cli, docker] = await Promise.all([
        (0, exports.checkForNpmUpdate)(version),
        shouldSkipDockerUpgradeCheck
            ? Promise.resolve(noop)
            : (0, exports.checkForDockerUpdate)(),
    ]);
    try {
        // update the modification time on the file
        fsx.writeFileSync(constants_1.STEPZEN_LAST_UPDATE_CHECK_TIMESTAMP, '');
    }
    catch {
        // ignore
    }
    return {
        message: [cli.message, docker.message].filter(Boolean).join('\n'),
        isBlocking: cli.isBlocking || docker.isBlocking,
    };
};
exports.maybeCheckForUpdates = maybeCheckForUpdates;
const hook = async function (options) {
    // parse the command line to get `flags['non-interactive']`
    const TheCommand = options.Command;
    const { args, flags } = await core_1.Parser.parse(options.argv, TheCommand);
    const { message, isBlocking } = await (0, exports.maybeCheckForUpdates)({
        version: this.config.version,
        command: options.Command.id,
        args,
    });
    // In a non-interactive shell only print the upgrade nudge if the upgrade
    // is blocking.
    // For non-blocking upgrades we don't want to print the upgrade nudge when
    // the CLI is executed as a part of a non-interactive shell script. This
    // additional output might by unexpected by the rest of script and could
    // break the pipeline.
    if (message && (isBlocking || !flags['non-interactive'])) {
        this.log('');
        this.log(message.trim());
        this.log('');
    }
    if (isBlocking) {
        // Not using this.exit() because of https://github.com/oclif/oclif/issues/1083
        // eslint-disable-next-line unicorn/no-process-exit, no-process-exit
        process.exit(1);
    }
};
exports.default = hook;
//# sourceMappingURL=check-upgrade.js.map
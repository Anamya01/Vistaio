"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportFlags = void 0;
const core_1 = require("@oclif/core");
const chalk = require("chalk");
/**
 * A helper to share flags between several import commands.
 */
exports.ImportFlags = {
    prefix: () => core_1.Flags.string({
        description: 'Prefix to add to every type in the generated schema',
    }),
    header: () => core_1.Flags.string({
        char: 'H',
        description: `Specifies a request header to pass` +
            `\n` +
            `\nExample:` +
            `\nstepzen import curl https://example.com/api/customers \\` +
            `\n\t-H ${chalk.bold('"Authorization: apikey SecretAPIKeyValue"')}`,
        multiple: true,
    }),
    headerParam: () => core_1.Flags.string({
        description: `Specifies a parameter in a header value.` +
            ` Can be formed by taking a ${chalk.bold('-H, --header')} flag and replacing the` +
            ` variable part of the header value with a ${chalk.bold('$paramName')} placeholder. Repeat this flag once for each header with a parameter.` +
            `\n` +
            `\nExample:` +
            `\nstepzen import curl https://example.com/api/customers \\` +
            `\n\t-H "Authorization: apikey SecretAPIKeyValue" \\` +
            `\n\t--header-param 'Authorization: apikey ${chalk.bold('$apikey')}'`,
        multiple: true,
    }),
    dbHost: () => core_1.Flags.string({
        description: 'Database host and optional port (as HOST[:PORT])',
    }),
    dbUser: () => core_1.Flags.string({
        description: 'Database user name',
    }),
    dbPassword: () => core_1.Flags.string({
        description: 'Database password',
    }),
    dbDatabase: () => core_1.Flags.string({
        description: 'Name of database to import',
    }),
    dbSchema: (opts = {}) => core_1.Flags.string({
        description: `Database schema to import tables from (default: ${opts.default || 'public'})`,
    }),
    dbLinkTypes: () => core_1.Flags.boolean({
        description: `Automatically link types based on` +
            ` foreign key relationships using @materializer` +
            ` ${chalk.dim('(https://stepzen.com/docs/features/linking-types)')}`,
    }),
    dbInclude: () => core_1.Flags.string({
        description: `Should the generated GraphQL schema` +
            ` be based only on database views, only on tables or on both`,
        options: ['tables-only', 'views-only', 'tables-and-views'],
    }),
    dbUseDeprecatedNaming: () => core_1.Flags.boolean({
        description: chalk `Use the {yellow deprecated} pre-2023 naming convention in the` +
            chalk ` generated GraphQL schema:` +
            chalk `\n\t- the generated type and property names are auto-capitalized` +
            chalk ` into PascalCase` +
            chalk `\n\t- the generated field names use the {italic getCustomer} and` +
            chalk ` {italic getCustomerList} style.` +
            chalk `\n` +
            chalk `\nOn the other hand, when using the default naming convention:` +
            chalk `\n\t- the generated type and property names match exactly the` +
            chalk ` DB table and column names` +
            chalk `\n\t- the generated field names use the {italic customer} and` +
            chalk ` {italic customerList} style.`,
    }),
};
//# sourceMappingURL=flags.js.map
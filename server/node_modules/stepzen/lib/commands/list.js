"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require("chalk");
const debug = require("debug");
const core_1 = require("@oclif/core");
const errors_1 = require("@oclif/core/lib/errors");
const actions_1 = require("../shared/actions");
const constants_1 = require("../shared/constants");
const zen_command_1 = require("../shared/zen-command");
const stepzen_sdk_1 = require("../shared/stepzen-sdk");
const configuration_1 = require("../shared/configuration");
const errors_2 = require("../shared/errors");
class List extends zen_command_1.default {
    async run() {
        const { args, flags } = await this.parse(List);
        const type = args.type;
        if (type !== 'endpoints') {
            this.warn(chalk `{yellow the type {bold ${type}} is deprecated and will be removed in future versions}` +
                chalk `\n\tSee more help with --help`);
        }
        const { configuration } = await this.ensureStepZenAccount({
            nonInteractive: flags['non-interactive'],
        });
        const { result, configuration: effectiveConfig, configMigrated, } = await (0, stepzen_sdk_1.tryZenCtl2ThenZenCtl1)(configuration, async (stepzen) => {
            if (stepzen.version === 'v2') {
                if (type !== 'endpoints') {
                    // zenctl2 does not support listing schemas and configuration sets
                    throw new errors_1.CLIError(chalk `{bold stepzen list ${type}} is no longer supported.` +
                        chalk ` Please use {bold stepzen list endpoints} instead.`);
                }
                // listing a non-deprecated type and the v2 API is available
                const client = await stepzen.client({
                    account: configuration.account,
                    adminKey: configuration.adminkey,
                    deploymentType: (0, constants_1.getDeploymentType)(configuration),
                });
                const response = await client.list.endpoints();
                // filter out the internal properties so that they are not printed out
                response.data?.forEach((endpoint) => {
                    delete endpoint.public;
                    delete endpoint.deploymentType;
                    delete endpoint.endpointType;
                });
                return response;
            }
            // the zenctl2 API is not available => using zenctl1
            const response = await (0, actions_1.list)(type);
            return response.success
                ? {
                    data: response.results || [],
                }
                : {
                    error: {
                        message: JSON.stringify(response.errors),
                    },
                };
        });
        if (configMigrated) {
            await (0, configuration_1.writeCredentialsAndServiceToConfigFile)(effectiveConfig, effectiveConfig.serviceInstance);
        }
        const { data, error } = result;
        if (data) {
            if (data.length === 0) {
                // Success, but no results
                this.log('No results.');
            }
            else if (typeof data[0] === 'string') {
                // Success. The server returns a list of results.
                // zenctl v1
                this.log(`${JSON.stringify(data, null, '  ')}`);
            }
            else {
                // zenctl v2
                const endpoints = data;
                // eslint-disable-next-line new-cap
                const dtf = new Intl.DateTimeFormat(undefined, {
                    dateStyle: 'medium',
                    timeStyle: 'short',
                });
                core_1.ux.table(endpoints, {
                    endpoint: {
                        get: row => `${row.folderName}/${row.endpointName}   `,
                    },
                    createdAt: {
                        header: 'Created at',
                        get: row => `${dtf.format(new Date(row.createdAt))}   `,
                    },
                    updatedAt: {
                        header: 'Updated at',
                        get: row => dtf.format(new Date(row.updatedAt)),
                    },
                });
            }
        }
        else {
            debug('stepzen:list')('failed to execute stepzen.list: ' + error.message);
            throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
        }
    }
}
exports.default = List;
List.description = `List endpoints, schemas and configuration sets in your StepZen account.` +
    chalk `\nAll timestamps displayed by {bold stepzen list endpoints} are in` +
    chalk ` your {underline local time zone}.`;
List.flags = {
    ...zen_command_1.default.flags,
};
List.args = {
    type: core_1.Args.string({
        default: 'endpoints',
        description: chalk `
        
        The type of entities to list:
        \t{bold endpoints} - GraphQL API endpoints deployed with {underline stepzen deploy} (or {underline stepzen start})
        \t{bold schemas} {yellow [DEPRECATED]} - StepZen schemas uploaded with {underline stepzen upload} (or {underline stepzen start})
        \t{bold configurationsets} {yellow [DEPRECATED]} - StepZen configuration sets uploaded with {underline stepzen upload} (or {underline stepzen start})`,
        options: ['endpoints', 'configurationsets', 'schemas'],
    }),
};
//# sourceMappingURL=list.js.map
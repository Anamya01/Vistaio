"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportCommandBase = void 0;
const core_1 = require("@oclif/core");
const errors_1 = require("@oclif/core/lib/errors");
const chalk = require("chalk");
const fsx = require("fs-extra");
const path = require("path");
const constants_1 = require("../shared/constants");
const inquirer = require("../shared/inquirer");
const rmtemp_1 = require("../shared/rmtemp");
const utils_1 = require("../shared/utils");
const zen_command_1 = require("../shared/zen-command");
const helpers_1 = require("./helpers");
class ImportCommandBase extends zen_command_1.default {
    async run() {
        const { flags } = await this.parse();
        // If using a local StepZen service instance, make sure it's running
        await this.awaitIntrospectionServiceUpIfLocal();
        // Get or create a StepZen workspace (possibly interactive)
        const workspace = await this.ensureStepZenWorkspace({
            directory: flags.dir,
            nonInteractive: flags['non-interactive'],
        });
        // Define a sane onConflict behaviour (possibly interactive)
        const onConflict = await this.ensureOnConflictBehavior(workspace, flags);
        // Common options for all import sources
        const commonOptions = {
            name: flags.name,
            source: workspace.schema,
            onConflict,
        };
        // Run the import command for the specific source:
        //  - ask for any missing required arguments (if not in non-interactive mode)
        //  - call the StepZen introspection service to generate a GraphQL schema
        const { result: response, error } = await this.import(commonOptions, workspace);
        if (error) {
            this.log('A problem occurred while processing your import.');
            this.log(error.message);
            return this.exit(1);
        }
        // Use @stepzen/transpiler to run the schema merge algorithm taking in
        // the new schema returned by the introspection service and the existing
        // workspace schema. The merged schema is written to a temp folder
        // (outPath).
        const { outPath } = await (0, helpers_1.writeSdlAndConfig)({
            name: flags.name || this.source,
            source: workspace.schema,
            // Merging types in the way it's done in @stepzen/transpiler leads to
            // issues (https://github.com/steprz/stepzen-cli/issues/875) but it's
            // still used for mysql for compatibility (because it was originally
            // implemented that way), and for other SQL sources for consistency.
            mergeTypes: ['snowflake', 'mysql', 'postgresql'].includes(this.source),
            onConflict,
            response,
        });
        try {
            // Last step - when both introspection and schema merge are done and the
            // merged schema is written in a temp folder, copy the result into the
            // workspace folder making the result visible to the user.
            fsx.copySync(outPath, workspace.schema);
            this.log(chalk `{green Successfully imported {bold ${this.source}} data source into your GraphQL schema}`);
        }
        finally {
            (0, rmtemp_1.rmtemp)(outPath);
        }
    }
    async ensureOnConflictBehavior(workspace, flags) {
        const detectNameConflicts = (0, utils_1.getFeatureFlag)(constants_1.DETECT_NAME_CONFLICTS);
        if (!detectNameConflicts) {
            return 'append';
        }
        const name = flags.name || this.source;
        const hasConflict = fsx.existsSync(path.join(workspace.schema, name));
        if (!hasConflict) {
            return 'append';
        }
        // No `--name` is given (i.e. naming is automatic)
        // Using the default name is going to lead to a conflict, and it should
        // be resolved by inventing a new unique name for the new schema.
        if (!flags.name) {
            return 'append';
        }
        // `--name` is given and (i.e. naming is namaged by the user)
        // There is a naming conflict.
        // The user has explicitly asked to overwrite the existing schema.
        if (flags.overwrite) {
            return 'overwrite';
        }
        // `--name` is given and (i.e. naming is namaged by the user)
        // There is a naming conflict.
        // The user has NOT given an explicit permission to overwrite the existing
        // schema.
        // In an interactive mode the CLI asks them for a confirmation.
        // In a non-interactive mode the CLI throws an error.
        if (flags['non-interactive']) {
            throw new errors_1.CLIError(`A schema named ${chalk.bold(flags.name)} already exists in this workspace. Add an ${chalk.bold('--overwrite')} flag to overwrite it.`);
        }
        this.log(`A schema named ${chalk.bold(flags.name)} already exists in this workspace. Would you like to overwrite it?`);
        const answers = await inquirer.prompt('import', [
            {
                name: 'overwrite',
                type: 'confirm',
                default: false,
                message: `Overwrite ${flags.name}?`,
            },
        ]);
        if (answers.overwrite) {
            return 'overwrite';
        }
        return this.exit();
    }
    async wrapInProgressAndTimeout(importPromise) {
        core_1.ux.action.start('Starting');
        try {
            let timeoutPromise = (0, utils_1.getTimeout)(5 * 1000);
            let resultOrError = await Promise.race([importPromise, timeoutPromise]);
            if (!resultOrError) {
                // 5 sec passed, but no result yet
                core_1.ux.action.start('Creating a GraphQL schema');
                timeoutPromise = (0, utils_1.getTimeout)(5 * 1000);
                resultOrError = await Promise.race([importPromise, timeoutPromise]);
            }
            if (!resultOrError) {
                // another 5 sec passed (10 sec total)
                core_1.ux.action.start('Creating a GraphQL schema (this is taking longer than usual)');
                timeoutPromise = (0, utils_1.getTimeout)(30 * 1000);
                resultOrError = await Promise.race([importPromise, timeoutPromise]);
            }
            if (!resultOrError) {
                // another 30 sec passed (40 sec total)
                core_1.ux.action.start('Creating a GraphQL schema (it may take up to 10 minutes)');
                timeoutPromise = (0, utils_1.getTimeout)((8 * 60 + 20) * 1000);
                resultOrError = await Promise.race([importPromise, timeoutPromise]);
            }
            if (resultOrError) {
                timeoutPromise.cancel();
            }
            else {
                // another 8 min 20 sec passed (9 min total)
                // 9 minutes is the max timeout in the introspection service. If it has
                // not responsed withing this time, there is no point in waiting longer.
                resultOrError = {
                    error: { message: 'The StepZen introspection service has timed out.' },
                };
            }
            core_1.ux.action.stop(resultOrError.error ? chalk.red('fail') : 'done');
            return resultOrError;
        }
        catch (error) {
            core_1.ux.action.stop(chalk.red('fail'));
            throw error;
        }
    }
}
exports.ImportCommandBase = ImportCommandBase;
ImportCommandBase.flags = {
    ...zen_command_1.default.flags,
    dir: core_1.Flags.string({ description: 'Working directory' }),
    silent: core_1.Flags.boolean({
        description: 'This is an internal flag passed by the (no-arg) Import command when' +
            ' it launches a data-source specific import command. The intent is' +
            ' to avoid showing a welcome message twice (if its already been shown' +
            ' by the (no-arg) Import command).',
        hidden: true,
    }),
    name: core_1.Flags.string({
        description: 'Subfolder inside the workspace folder to save the imported' +
            ' schema files to. Defaults to the name of the imported schema.',
    }),
    overwrite: core_1.Flags.boolean({
        description: 'Overwrite any existing schema with the same name. Cannot be used' +
            ' without also providing a --name flag.',
        dependsOn: ['name'],
        hidden: true,
    }),
};
//# sourceMappingURL=import-command.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.overrideDefaults = exports.prompt = exports.writeLastAnswers = exports.clearHistoryKey = exports.historyKey = void 0;
// Copyright IBM Corp. 2020, 2024
const crypto = require("crypto");
const debug = require("debug");
const fs = require("fs");
const inquirer = require("inquirer");
const lodash_1 = require("lodash");
const path = require("path");
const yaml = require("yaml");
const configuration_1 = require("./configuration");
const constants_1 = require("./constants");
const CIPHER_ALGORITHM = 'aes-256-cbc';
const readHistoryKey = async () => {
    const config = await (0, configuration_1.readConfiguration)();
    if (!('adminkey' in config)) {
        debug('stepzen:inquirer')('history not available due to not logged in');
        return undefined;
    }
    try {
        const loggedInConfig = config;
        const adminkeyParts = config.adminkey.split('::');
        if (config.uuid.length !== 36 ||
            adminkeyParts.length !== 3 ||
            adminkeyParts[2].length !== 64) {
            debug('stepzen:inquirer')('account does not support history');
            return undefined;
        }
        const password = Buffer.from(adminkeyParts[2], 'hex');
        const initVector = Buffer.from(loggedInConfig.uuid.replace(/-/g, ''), 'hex');
        const salt = initVector;
        const key = crypto.scryptSync(password, salt, 32);
        // base the file name of the encrypted account name, to not reveal
        // which accounts have been logged in but still have history survive
        // login-logout cycles
        const cipher = crypto.createCipheriv(CIPHER_ALGORITHM, key, initVector);
        const encryptedAccountName = Buffer.concat([
            cipher.update(config.account),
            cipher.final(),
        ]);
        const historyFile = path.join(constants_1.STEPZEN_HISTORY_DIRECTORY, constants_1.STEPZEN_HISTORY_FILE.replace('{accounthash}', encryptedAccountName.toString('hex')));
        exports.historyKey = { historyFile, key, initVector };
        return exports.historyKey;
    }
    catch (error) {
        debug('stepzen:inquirer')(error);
        return undefined;
    }
};
const getHistoryKey = async () => {
    if (exports.historyKey) {
        return exports.historyKey;
    }
    return readHistoryKey();
};
// for unit tests
const clearHistoryKey = () => {
    exports.historyKey = undefined;
};
exports.clearHistoryKey = clearHistoryKey;
const readLastAnswers = async () => {
    const details = await getHistoryKey();
    if (details === undefined) {
        return {};
    }
    if (!fs.existsSync(details.historyFile)) {
        debug('stepzen:inquirer')(`no history file (${details.historyFile}) found`);
        return {};
    }
    try {
        const decipher = crypto.createDecipheriv(CIPHER_ALGORITHM, details.key, details.initVector);
        const encryptedContent = fs.readFileSync(details.historyFile);
        const content = Buffer.concat([
            decipher.update(encryptedContent),
            decipher.final(),
        ]);
        const result = yaml.parse(content.toString('utf8'));
        if (result === null) {
            debug('stepzen:inquirer')(`unable to parse history file (${details.historyFile})`);
            return {};
        }
        return result;
    }
    catch (error) {
        debug('stepzen:inquirer')(error);
        return {};
    }
};
const writeLastAnswers = async (answers) => {
    const details = await getHistoryKey();
    if (details === undefined) {
        return;
    }
    if (!fs.existsSync(constants_1.STEPZEN_HISTORY_DIRECTORY)) {
        fs.mkdirSync(constants_1.STEPZEN_HISTORY_DIRECTORY);
    }
    const content = yaml.stringify(answers);
    const cipher = crypto.createCipheriv(CIPHER_ALGORITHM, details.key, details.initVector);
    const encryptedContent = Buffer.concat([
        cipher.update(content),
        cipher.final(),
    ]);
    fs.writeFileSync(details.historyFile, encryptedContent, { mode: '600' });
};
exports.writeLastAnswers = writeLastAnswers;
const prompt = async (namespace, questions, initialAnswers) => {
    const last = await readLastAnswers();
    const questionList = Array.isArray(questions) ? questions : [questions];
    const lastThisNs = namespace in last ? last[namespace] : {};
    const questionsToAsk = questionList.map(question => {
        if (question.name !== undefined &&
            question.name in lastThisNs &&
            question.default === undefined) {
            return { ...question, default: lastThisNs[question.name] };
        }
        return question;
    });
    const result = await inquirer.prompt(questionsToAsk, initialAnswers);
    (0, exports.writeLastAnswers)({ ...last, ...{ [namespace]: { ...lastThisNs, ...result } } });
    return result;
};
exports.prompt = prompt;
const overrideDefaults = (questions, defaultAnswers) => {
    return questions.map(question => {
        const def = (0, lodash_1.get)(defaultAnswers, question.name);
        return def === undefined ? question : { ...question, default: def };
    });
};
exports.overrideDefaults = overrideDefaults;
//# sourceMappingURL=inquirer.js.map
import { Input } from '@oclif/core/lib/interfaces/parser';
import type { StepZenCredentials } from '@stepzen/sdk/lib/client';
export { StepZenCredentials, StepZenCredentialsV2, ZenCtlResponse, } from '@stepzen/sdk/lib/client';
export declare type FlagsT<Command> = Command extends Input<infer F, infer _B, infer _A> ? F : never;
export declare type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export declare type Defined<T> = {
    [P in keyof T]-?: NonNullable<T[P]>;
};
/**
 * A utility type for cases when you prefer to explicitly return an error
 * value from a function rather than throwing an exception.
 *
 * The optional `error?: never` property is a trick to make the TS compiler
 * accept both `{ result: ... }` and `{ error: ... }` as valid return values.
 *
 * The default error type is `{message: string}` rather than a plain `string`
 * to allow the TS compiler to infer the `result` type from `if (error)`
 * checks. When `error` is an object it may be falsy only when undefined (which
 * implies `result` is defined). When `error` is a string, it may be falsy
 * even if it has a value (if it's an empty string). This means a simple
 * `if (!error)` condition is not sufficient to assume `result` is defined.
 *
 * Intended usage (on the caller side):
 * ```
 * const {result, error} = foo()
 * if (error) {
 *   // error is defined here
 * } else {
 *   // result is defined here
 * }
 * ```
 */
export declare type ErrorOr<T, E = {
    message: string;
}> = {
    result: T;
    error?: never;
} | {
    error: E;
    result?: never;
};
export interface ServiceInstanceV1 {
    zenctl?: string;
    introspection?: string;
    dbintrospection?: string;
}
export interface ServiceInstanceV2 {
    deploymentType: string;
    zenctl2: string;
    introspection?: string;
    dbintrospection?: string;
}
export declare type ServiceInstance = ServiceInstanceV1 | ServiceInstanceV2;
export declare type LoggedOutMachineConfiguration = {
    uuid: string;
    serviceInstance?: ServiceInstance;
};
export declare type LoggedInMachineConfiguration = LoggedOutMachineConfiguration & StepZenCredentials;
/**
 * In-memory representation of the `~/.stepzen/stepzen-config.yaml`
 * configuration file.
 *
 * If the user is not logged in, it has only a UUID of the CLI installation.
 * If the user is logged in, it has also has the StepZen account credentials.
 */
export declare type MachineConfiguration = LoggedInMachineConfiguration | LoggedOutMachineConfiguration;
/**
 * On-disk representation of a workspace config file, `stepzen.config.json`
 */
export interface WorkspaceConfiguration {
    endpoint: string;
    root?: string;
}
/**
 * In-memory representation of a workspace config
 */
export interface Workspace {
    endpoint: string;
    directory: string;
    schema: string;
}
//# sourceMappingURL=types.d.ts.map
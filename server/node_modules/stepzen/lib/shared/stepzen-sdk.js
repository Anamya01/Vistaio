"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryZenCtl2ThenZenCtl1 = exports.hasSdkInterfaceV2 = exports.getSdkInterfaceV1 = exports.getStepzen2SDK = exports.getStepzen1SDK = void 0;
const errors_1 = require("@oclif/core/lib/errors");
const sdk_1 = require("@stepzen/sdk");
const debug_1 = require("debug");
const constants_1 = require("./constants");
const { version } = require('../../package.json');
const getStepzen1SDK = (zenServer) => {
    const stepzen1 = {
        version: 'v1',
        ...(0, sdk_1.init)({ appName: `stepzen-cli/${version}` }),
        login: async (adminkey, account = adminkey.split(':')[0]) => {
            try {
                const client = await stepzen1.client({
                    account,
                    adminkey,
                    server: zenServer,
                });
                return client.credentials;
            }
            catch (error) {
                // Exit, with error
                throw new errors_1.CLIError('We are unable to verify your account details. Could you please check them?' +
                    ` (${error})`);
            }
        },
        createAnonymousAccount: async (uuid) => {
            try {
                const client = await stepzen1.client({
                    publicAccountToken: uuid,
                    server: zenServer,
                });
                return client.credentials;
            }
            catch (error) {
                throw new errors_1.CLIError(`Could not create a public account (${error})`);
            }
        },
    };
    return stepzen1;
};
exports.getStepzen1SDK = getStepzen1SDK;
const getStepzen2SDK = (zenctlApiUrl, deploymentType) => {
    const publicAccountApiUrl = process.env.STEPZEN_PUBLIC_ACCOUNT_API_URL ||
        new URL(zenctlApiUrl).origin + constants_1.ZENCTL2_PUBLIC_ACCOUNT_URL;
    const stepzen2 = {
        version: 'v2',
        ...(0, sdk_1.initV2)({
            appName: `stepzen-cli/${version}`,
            zenctlApiUrl,
            publicAccountApiUrl,
            apiVersion: 'v2',
        }),
        login: async (adminKey, account = adminKey.split(':')[0]) => {
            try {
                const client = await stepzen2.client({
                    account,
                    adminKey,
                    deploymentType,
                });
                return client.credentials;
            }
            catch (error) {
                // Exit, with error
                throw new errors_1.CLIError('We are unable to verify your account details. Could you please check them?' +
                    ` (${error})`);
            }
        },
        createAnonymousAccount: async (uuid) => {
            try {
                const client = await stepzen2.client({
                    publicAccountToken: uuid,
                    deploymentType,
                });
                return client.credentials;
            }
            catch (error) {
                throw new errors_1.CLIError(`Could not create a public account (${error})`);
            }
        },
        get serviceInstance() {
            return {
                deploymentType,
                zenctl2: zenctlApiUrl,
            };
        },
    };
    return stepzen2;
};
exports.getStepzen2SDK = getStepzen2SDK;
const getSdkInterfaceV1 = (configuration) => {
    return (0, exports.getStepzen1SDK)((0, constants_1.getZenCtlUrlTemplate)(configuration));
};
exports.getSdkInterfaceV1 = getSdkInterfaceV1;
const hasSdkInterfaceV2 = (configuration) => {
    const isOnZenCtl2 = configuration.serviceInstance &&
        'zenctl2' in configuration.serviceInstance &&
        configuration.serviceInstance.zenctl2;
    return isOnZenCtl2;
};
exports.hasSdkInterfaceV2 = hasSdkInterfaceV2;
/**
 * Try using the ZenCtl2 API first, and if that throws fallback to using the
 * ZenCtl1 API. This logic allows a gradual transition of user accounts from
 * API v1 to API v2.
 *
 * @param {*} configuration `stepzen.config.yaml` file content
 * @param {*} fn function to execute with the `stepzen` API object (v2 or v1)
 * @returns {*} return value of `fn`
 */
async function tryZenCtl2ThenZenCtl1(configuration, fn) {
    let result;
    const isOnZenCtl2 = (0, exports.hasSdkInterfaceV2)(configuration);
    let configMigrated = false;
    let serviceInstance;
    try {
        const stepzen2 = (0, exports.getStepzen2SDK)((0, constants_1.getZenCtl2Url)(configuration), (0, constants_1.getDeploymentType)(configuration));
        result = await fn(stepzen2);
        serviceInstance = {
            ...configuration.serviceInstance,
            ...stepzen2.serviceInstance,
        };
        configMigrated =
            !configuration.serviceInstance ||
                !('zenctl2' in configuration.serviceInstance);
    }
    catch (v2Error) {
        try {
            const stepzen1 = (0, exports.getStepzen1SDK)((0, constants_1.getZenCtlUrlTemplate)(configuration));
            result = await fn(stepzen1);
        }
        catch (v1Error) {
            if (isOnZenCtl2) {
                (0, debug_1.default)('stepzen:sdk')('a tryZenCtl2ThenZenCtl1() call failed both with SDKv1 and SDKv2;' +
                    ' re-throwing the SDK v2 error and dumping the SDK v1 error here:' +
                    v1Error);
                throw v2Error;
            }
            (0, debug_1.default)('stepzen:sdk')('a tryZenCtl2ThenZenCtl1() call failed both with SDKv1 and SDKv2;' +
                ' re-throwing the SDK v2 error and dumping the SDK v2 error here:' +
                v2Error);
            throw v1Error;
        }
    }
    return {
        result,
        serviceInstance,
        configuration: {
            ...configuration,
            serviceInstance,
        },
        configMigrated,
    };
}
exports.tryZenCtl2ThenZenCtl1 = tryZenCtl2ThenZenCtl1;
//# sourceMappingURL=stepzen-sdk.js.map
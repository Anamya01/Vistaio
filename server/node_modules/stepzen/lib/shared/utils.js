"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.probeEndpoint = exports.getTimeout = exports.prependEachLine = exports.rewriteLocalhostToHostGatewayInURL = exports.rewriteLocalhostToHostGateway = exports.maskPasswordInDsn = exports.parseSnowflakeAccountId = exports.formatEndpointInfo = exports.hasWebDashboard = exports.getFeatureFlag = exports.maskStepZenKey = exports.validateEndpoint = exports.getStepZenExtensions = exports.workspaceRelative = exports.homeRelative = exports.getDirectory = void 0;
const errors_1 = require("@oclif/core/lib/errors");
const chalk = require("chalk");
const debug = require("debug");
const fetch_1 = require("@stepzen/fetch");
const fs = require("fs");
const os = require("os");
const path = require("path");
const prettier = require("prettier");
const configuration_1 = require("./configuration");
const constants_1 = require("./constants");
const url_helpers_1 = require("./url-helpers");
const SAMPLE_QUERY = `query SampleQuery { __schema { description queryType { fields {name} } } }`;
const getDirectory = (d = process.cwd()) => {
    let directory = d;
    // If it starts with `~`, expand this
    if (directory.startsWith('~')) {
        directory = directory.replace('~', os.homedir());
    }
    // If it does not now start with `/`, then get the absolute path.
    // Also, remove any `..` and `.` segments.
    directory = path.resolve(directory);
    // If the path does not exist, throw an error
    if (!fs.existsSync(directory)) {
        throw new errors_1.CLIError(`Cannot find ${directory}`);
    }
    return directory;
};
exports.getDirectory = getDirectory;
/**
 * Replace the path prefix with `~` if it is inside the user's home directory.
 *
 * @param {*} absPath an absolute file or directory path
 * @returns {*} the same path that possibly looks more friendly to users
 */
const homeRelative = (absPath) => {
    let pretty = absPath;
    if (absPath.startsWith(os.homedir())) {
        pretty = '~' + absPath.substring(os.homedir().length);
    }
    return pretty;
};
exports.homeRelative = homeRelative;
/**
 * Replace the path prefix with `~` if it is inside the user's home directory.
 *
 * @param {*} absPath an absolute file or directory path
 * @param {*} workspace an absolute file or the workspace root
 * @returns {*} the same path that possibly looks more friendly to users
 */
const workspaceRelative = (absPath, workspace) => {
    let pretty = absPath;
    if (absPath.startsWith(workspace)) {
        pretty = '.' + absPath.substring(workspace.length);
    }
    return pretty;
};
exports.workspaceRelative = workspaceRelative;
const getStepZenExtensions = async (configuration) => {
    if (!configuration) {
        configuration = await (0, configuration_1.readConfiguration)();
    }
    const zenserv = (0, constants_1.getZenServUrlTemplate)(configuration).replace('{account}', 'stepzen');
    const url = `${zenserv}/directives.graphql`;
    const startedAt = new Date().getTime();
    debug('stepzen:extensions')(`fetching StepZen extensions from ${url}`);
    const response = await (0, fetch_1.default)(url);
    const schema = await response.text();
    const formatted = prettier.format(schema, { parser: 'graphql' });
    const doneAt = new Date().getTime();
    debug('stepzen:extensions')(`fetched extensions (${formatted.length} bytes, ${doneAt - startedAt} ms)`);
    return formatted;
};
exports.getStepZenExtensions = getStepZenExtensions;
const validateEndpoint = (endpoint) => {
    const error = chalk `Expected the endpoint name to be of the format {bold folder/name},` +
        chalk ` matching the pattern {bold ^[\\w-]+$}` +
        chalk ` but got {bold ${endpoint}}.`;
    if (endpoint.includes('/') === false)
        return error;
    const parts = endpoint.split('/');
    if (parts.some(part => part.trim() === ''))
        return error;
    if (parts.some(part => part.match(/^[\d_-]+/)))
        return error;
    if (parts.some(part => !part.match(/^[\w-]+$/)))
        return error;
    return true;
};
exports.validateEndpoint = validateEndpoint;
const maskStepZenKey = (key) => {
    const parts = key.split('::');
    const thirdPart = parts[2];
    const firstTwoChars = thirdPart.substring(0, 2);
    const lastTwoChars = thirdPart.slice(-2);
    const stars = '*'.repeat(thirdPart.length - 4);
    const maskedThirdPart = `${firstTwoChars}${stars}${lastTwoChars}`;
    const masked = `${parts[0]}::${parts[1]}::${maskedThirdPart}  `;
    return masked;
};
exports.maskStepZenKey = maskStepZenKey;
const getFeatureFlag = (flag) => {
    const value = process.env[flag];
    if (value === undefined) {
        return false;
    }
    return value.toLowerCase() !== 'false';
};
exports.getFeatureFlag = getFeatureFlag;
const hasWebDashboard = (configuration) => {
    // At the moment the Web StepZen Dashboard https://dashboard.stepzen.com only
    // works with the endpoints deployed to the production GCP servers:
    // stepzen.net
    const hostname = (0, constants_1.getZenServDomain)(configuration);
    return hostname === 'stepzen.net' || hostname === 'steprz.net';
};
exports.hasWebDashboard = hasWebDashboard;
const formatEndpointInfo = ({ configuration, endpoint, graphiql = {
    type: (0, exports.hasWebDashboard)(configuration) ? 'web' : 'none',
}, }) => {
    const account = configuration.account;
    const zenserv = (0, constants_1.getZenServUrl)(configuration);
    const isPublic = account.startsWith('public');
    const url = `${zenserv}/${endpoint}/__graphql`;
    const subsurl = `${zenserv.replace(/^http/i, 'ws')}/stepzen-subscriptions/${endpoint}/__graphql`;
    const lines = [];
    const icon = (0, url_helpers_1.isLocalhost)(zenserv) ? '💻' : isPublic ? '🌐' : '🔐';
    lines.push(chalk `  {green ✓ ${icon} ${url}}`);
    lines.push(chalk `  {green ✓ ${icon} ${subsurl}} {grey ({bold subscriptions})}`);
    lines.push('');
    if (process.platform === 'win32') {
        lines.push(chalk.grey(`In PowerShell you can test your hosted API with Invoke-WebRequest:`));
        lines.push('');
        lines.push(`Invoke-WebRequest \``);
        lines.push(`   -Uri ${url} \``);
        lines.push(`   -UseBasicParsing \``);
        lines.push(`   -Method "POST" \``);
        lines.push(`   -Headers @{`);
        lines.push(`     "Content-Type" = "application/json"`);
        if (!isPublic) {
            lines.push(`     "Authorization" = "APIKey $(stepzen whoami --apikey)"`);
        }
        lines.push(`   } \``);
        lines.push(`   -Body (@{`);
        lines.push(`     "query" = '${SAMPLE_QUERY}'`);
        lines.push(`   } | ConvertTo-Json)`);
    }
    else {
        lines.push(chalk.grey(`You can test your hosted API with curl:`));
        lines.push('');
        lines.push(`curl ${url} \\`);
        if (!account.startsWith('public')) {
            lines.push(`   --header "Authorization: Apikey $(stepzen whoami --apikey)" \\`);
        }
        lines.push(`   --header "Content-Type: application/json" \\`);
        lines.push(`   --data-raw '{`);
        lines.push(`     "query": "${SAMPLE_QUERY}"`);
        lines.push(`   }'`);
    }
    if (graphiql.type !== 'none') {
        const graphiqlUrl = graphiql.type === 'local'
            ? `http://localhost:${graphiql.port}/${endpoint}`
            : `https://dashboard.stepzen.com/explorer?endpoint=${encodeURIComponent(isPublic ? url : endpoint)}`;
        lines.push('');
        lines.push(chalk.grey(`Or explore it with GraphiQL at`));
        lines.push(`   ${graphiqlUrl}`);
    }
    lines.push('');
    return lines.join('\n');
};
exports.formatEndpointInfo = formatEndpointInfo;
const parseSnowflakeAccountId = (accountId) => {
    if (!accountId) {
        return { error: { message: 'Snowflake account identifier must not be empty' } };
    }
    // try parsing accountId either as `org.account` or as `org-account`
    // see https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#account-name
    const re = /^(?<org>[a-zA-Z0-9]+)(\.|-)(?<acc>[a-zA-Z0-9_-]+)$/i;
    const match = accountId.match(re);
    if (!match || !match.groups || !match.groups.org || !match.groups.acc) {
        return {
            error: {
                message: chalk `The provided Snowflake account identifier "${accountId}"` +
                    chalk ` does not match the expected format. It should be either` +
                    chalk ` {bold ORG}.{bold ACCOUNT} or {bold ORG}-{bold ACCOUNT}`,
            },
        };
    }
    return {
        result: {
            organization: match.groups.org,
            account: match.groups.acc,
        },
    };
};
exports.parseSnowflakeAccountId = parseSnowflakeAccountId;
// postgresql://ctluser:ctlpass@example.org/ctldb --> postgresql://ctluser:***@example.org/ctldb
// postgresql://example.org/ctldb?user=ctluser&password=crlpass --> postgresql://example.org/ctldb?user=ctluser&password=***
function maskPasswordInDsn(dsn) {
    try {
        const url = new URL(dsn);
        if (url.username) {
            url.password = '***';
        }
        if (url.searchParams.get('password')) {
            url.searchParams.set('password', '***');
        }
        return url.href;
    }
    catch (error) {
        debug('stepzen:utils')(`failed to parse ${dsn} as a URL`, error);
        return dsn;
    }
}
exports.maskPasswordInDsn = maskPasswordInDsn;
function rewriteLocalhostToHostGateway(config, hostname) {
    const { host, port, isValid } = (0, url_helpers_1.parseHost)(hostname);
    if (isValid && (0, url_helpers_1.isLocalhost)(host)) {
        if (config.serviceInstance &&
            'zenctl2' in config.serviceInstance &&
            (0, url_helpers_1.isLocalhost)(config.serviceInstance.zenctl2)) {
            return `host.docker.internal${port ? `:${port}` : ''}`;
        }
        throw new errors_1.CLIError(`${chalk.bold('stepzen import')} only supports loopback introspection when running a local service (see ${chalk.dim('stepzen service --help')} for more information)`);
    }
    return hostname;
}
exports.rewriteLocalhostToHostGateway = rewriteLocalhostToHostGateway;
function rewriteLocalhostToHostGatewayInURL(config, url) {
    let parsed;
    try {
        parsed = new URL(url);
    }
    catch (error) {
        debug('stepzen:utils')(`failed to parse ${url} as a URL`, error);
        return url;
    }
    parsed.host = rewriteLocalhostToHostGateway(config, parsed.host);
    return parsed.toString();
}
exports.rewriteLocalhostToHostGatewayInURL = rewriteLocalhostToHostGatewayInURL;
function prependEachLine(text, prefix) {
    return prefix + text.replace(/\n/gm, `\n${prefix}`);
}
exports.prependEachLine = prependEachLine;
/**
 * Create a Promise that completes within the given duration, unless
 * cancelled.
 *
 * @param {*} ms milliseconds before completion
 * @returns {*} a Promise
 */
function getTimeout(ms) {
    let timeoutId;
    const promise = new Promise(resolve => {
        timeoutId = setTimeout(resolve, ms);
    });
    promise.cancel = () => clearTimeout(timeoutId);
    return promise;
}
exports.getTimeout = getTimeout;
/**
 *
 * Check if an endpoint is up; if not 200 OK after given number of tries raise an
 * exception. For graphql, send a simple introspection query.
 *
 * @param {*} url url to a web service
 * @param {*} tries number of attempts at 3-second intervals
 * @returns {*} a promise that completes if the service is up, otherwise fails
 */
async function probeEndpoint(url, tries = 5) {
    try {
        debug('stepzen:utils')(chalk `fetching {cyan ${url}}`);
        if (url.endsWith('graphql')) {
            // Assume a graphql endpoint; a plain GET will return 200, but provokes errors in the
            // introspection log; so send a trivial but fine introspection query
            url += '?query={__schema {__typename}}';
        }
        const response = await (0, fetch_1.default)(url);
        debug('stepzen:utils')(chalk `\t--> ${response.status}`);
        if (response.status === 200) {
            return;
        }
    }
    catch (error) {
        debug('stepzen:utils')(chalk `\t--> ${error}`);
    }
    if (tries > 0) {
        const waitMillis = 3000;
        debug('stepzen:utils')(chalk `will attempt to fetch {cyan ${url}} again in ${waitMillis}ms`);
        await getTimeout(waitMillis);
        return probeEndpoint(url, tries - 1);
    }
    throw new errors_1.CLIError(`Could not connect to the service at ${url}.`);
}
exports.probeEndpoint = probeEndpoint;
//# sourceMappingURL=utils.js.map
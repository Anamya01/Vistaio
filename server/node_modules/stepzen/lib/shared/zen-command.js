"use strict";
// Copyright IBM Corp. 2020, 2024
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZenCommand = void 0;
const core_1 = require("@oclif/core");
const errors_1 = require("@oclif/core/lib/errors");
const validate_1 = require("@oclif/core/lib/parser/validate");
const inquirer = require("inquirer");
const chalk = require("chalk");
const process = require("process");
const configuration_1 = require("./configuration");
const url_helpers_1 = require("./url-helpers");
const utils_1 = require("./utils");
const workspace_1 = require("./workspace");
const stepzen_sdk_1 = require("./stepzen-sdk");
const constants_1 = require("./constants");
class ZenCommand extends core_1.Command {
    async getServiceInstanceIfLocal(configuration) {
        configuration = configuration || (await (0, configuration_1.readConfiguration)());
        if (configuration.serviceInstance &&
            'zenctl2' in configuration.serviceInstance &&
            (0, url_helpers_1.isLocalhost)(configuration.serviceInstance.zenctl2)) {
            return configuration.serviceInstance;
        }
        // not using a local StepZen service instance => not local
        return undefined;
    }
    async awaitStepZenServiceUpIfLocal(configuration) {
        const serviceInstance = await this.getServiceInstanceIfLocal(configuration);
        if (serviceInstance === undefined) {
            // not logged-in to local service => this check does not apply
            return;
        }
        const zenctl2 = serviceInstance.zenctl2;
        try {
            await (0, utils_1.probeEndpoint)(zenctl2.replace(constants_1.ZENCTL2_URL, '/healthz'));
        }
        catch (error) {
            throw new errors_1.CLIError(chalk `Could not connect to the local StepZen service instance you are logged in to.` +
                chalk ` Please make sure the local StepZen service instance is running with` +
                chalk ` {bold stepzen service start}, or log in to the StepZen cloud with` +
                chalk ` {bold stepzen login}.`);
        }
    }
    async awaitIntrospectionServiceUpIfLocal(configuration) {
        const serviceInstance = await this.getServiceInstanceIfLocal(configuration);
        if (serviceInstance === undefined) {
            // not logged-in to local service => this check does not apply
            return;
        }
        const promises = [];
        const dbIntrospectionUrl = serviceInstance.dbintrospection;
        if (dbIntrospectionUrl !== undefined) {
            promises.push((0, utils_1.probeEndpoint)(dbIntrospectionUrl));
        }
        const introspectionUrl = serviceInstance.introspection;
        if (introspectionUrl !== undefined) {
            promises.push((0, utils_1.probeEndpoint)(introspectionUrl));
        }
        try {
            await Promise.all(promises);
        }
        catch (error) {
            throw new errors_1.CLIError(chalk `Could not connect to the local StepZen introspection service.` +
                chalk ` Please make sure the local StepZen service instance is running with` +
                chalk ` {bold stepzen service start}, or log in to the StepZen cloud with` +
                chalk ` {bold stepzen login}.`);
        }
    }
    async ensureStepZenAccount(options = {}) {
        const configuration = await (0, configuration_1.readConfiguration)();
        if (!('account' in configuration)) {
            if (options.nonInteractive) {
                throw new errors_1.CLIError(chalk `Could not proceed while not logged in. ` +
                    chalk ` Please login to your StepZen account by running {bold stepzen login}.`);
            }
            else {
                return this.promptUserToLogIn(configuration);
            }
        }
        await this.awaitStepZenServiceUpIfLocal(configuration);
        return {
            configuration,
        };
    }
    async ensureStepZenWorkspace(options = {}) {
        let workspace;
        const directory = (0, utils_1.getDirectory)(options.directory);
        const maybeWorkspace = (0, workspace_1.getWorkspace)(directory);
        if (maybeWorkspace) {
            workspace = maybeWorkspace;
        }
        else if (options.nonInteractive) {
            throw new errors_1.CLIError(`Could not find a StepZen workspace in the ${options.directory ? directory : 'current'} directory.` +
                chalk `\n  Please run {bold stepzen init${options.directory ? ` ${options.directory}` : ''}} once to create it.`);
        }
        else {
            try {
                workspace = await (0, workspace_1.initWorkspace)({
                    directory,
                    endpoint: options.endpoint,
                });
            }
            catch (error) {
                throw new errors_1.CLIError(`Could not create a StepZen workspace in the ${options.directory ? directory : 'current'} directory.\n` + error.message);
            }
        }
        // Emphasize that the workspace is not the _current_ directory.
        if (workspace.directory !== process.cwd() && !options.silent) {
            this.log();
            this.log(` ⤴️  Using the StepZen workspace in ${chalk.blue((0, utils_1.homeRelative)(workspace.directory))}`);
            this.log();
        }
        return workspace;
    }
    async promptUserToLogIn(initialConfiguration) {
        this.log(chalk.bold(chalk.cyan('Welcome to the StepZen CLI!')));
        this.log('');
        this.log(`You must be logged in to proceed. Please log in or create a` +
            ` StepZen account to get a production-ready GraphQL API` +
            ` deployed on a secure and private endpoint.`);
        this.log('');
        const answers = await inquirer.prompt([
            {
                message: 'How would you like to continue?',
                name: 'loginPath',
                type: 'list',
                choices: [
                    'Log in via stepzen.com',
                    'Continue without logging in (make your API public)',
                ],
            },
        ]);
        let configuration;
        if (answers.loginPath === 'Log in via stepzen.com') {
            const answers = await inquirer.prompt([
                {
                    message: 'What is your Admin Key?',
                    name: 'adminkey',
                    type: 'password',
                    validate: async (value) => {
                        try {
                            await (0, stepzen_sdk_1.tryZenCtl2ThenZenCtl1)(initialConfiguration, stepzen => stepzen.login(value));
                            return true;
                        }
                        catch (error) {
                            return `${error}`;
                        }
                    },
                    suffix: chalk.blue(` (available at ${chalk.bold('https://stepzen.com/account')})`),
                },
            ]);
            const { result: credentials, serviceInstance } = await (0, stepzen_sdk_1.tryZenCtl2ThenZenCtl1)(initialConfiguration, stepzen => stepzen.login(answers.adminkey));
            configuration = await (0, configuration_1.writeCredentialsAndServiceToConfigFile)(credentials, serviceInstance);
            this.log('You have successfully logged in.');
            this.log('');
        }
        else {
            const { result: credentials, serviceInstance } = await (0, stepzen_sdk_1.tryZenCtl2ThenZenCtl1)(initialConfiguration, stepzen => stepzen.createAnonymousAccount(initialConfiguration.uuid));
            configuration = await (0, configuration_1.writeCredentialsAndServiceToConfigFile)(credentials, serviceInstance);
            this.log(`We've created a temporary public account for you.\nAll endpoints` +
                ` deployed to this account will be automatically deleted after 24` +
                ` hours. You can log in with your regular StepZen account at any` +
                ` time by running ${chalk.bold('stepzen login')}.`);
            this.log('');
        }
        return { configuration };
    }
    // Override only to change the TS type signature.
    // The implementation is identical to that in the Command super class.
    exit(code = 0) {
        return core_1.Errors.exit(code);
    }
    // Customise the default `parse()` implementation to work around an oclif's
    // parser issue. It incorrectly parses multi-value flags such as
    // '--header-param', '--header', '--var' and others.
    // https://github.com/oclif/oclif/issues/261
    // https://github.com/oclif/core/issues/496
    //
    // This implementation uses copied fragments of the original oclif's parse()
    async parse(options = this.ctor, argv = this.argv) {
        const flags = options.flags || {};
        const args = options.args || {};
        const multiValueFlagNames = Object.keys(flags).filter(flag => 'multiple' in flags[flag] &&
            flags[flag].multiple);
        if (multiValueFlagNames.length === 0) {
            // no multi-value flags => nothing to fix => use the default parse() impl
            return super.parse(options, argv);
        }
        const orderedArgNames = Object.keys(args);
        // Make a copy of `args` with the `required` property disabled.
        const argsAsOptional = Object.fromEntries(Object.entries(args).map(([argName, argDef]) => [
            argName,
            argDef.required ? { ...argDef, required: false } : argDef,
        ]));
        // 1. run the default `parse()` method with modified input
        const parsed = (await super.parse({
            ...options,
            flags,
            // Make all args optional because `parse()` may incorrecly mark them as
            // flags, and then validation would fail.
            args: argsAsOptional,
        }, argv));
        const fixFlag = (flag) => {
            const values = parsed.flags[flag];
            if (values) {
                // Every ['--flag', value] pair in the argv array should match
                // only one value in the flag's value list.
                const matchedIndices = new Set();
                // For each value in the flag's value list, find the original
                // ['--flag', value] pair in the argv array.
                for (let i = 0; i < values.length; i++) {
                    const value = values[i];
                    const flagIdx = argv.findIndex((arg, idx) => {
                        // https://oclif.io/docs/flags#alternative-flag-inputs
                        // $ mycli --file foo
                        // $ mycli -f foo
                        const spaceDelimMatch = (arg === `--${flag}` ||
                            (flags[flag].char && arg === `-${flags[flag].char}`) ||
                            (flags[flag].aliases &&
                                flags[flag].aliases?.some(alias => arg === `--${alias}`))) &&
                            idx < argv.length &&
                            argv[idx + 1] === value;
                        // $ mycli --file=foo
                        // $ mycli -f=foo
                        const eqlDelimMatch = arg === `--${flag}=${value}` ||
                            (flags[flag].char && arg === `-${flags[flag].char}=${value}`) ||
                            (flags[flag].aliases &&
                                flags[flag].aliases?.some(alias => arg === `--${alias}=${value}`));
                        // $ mycli -ffoo
                        const noDelimMatch = flags[flag].char && arg === `-${flags[flag].char}${value}`;
                        return ((spaceDelimMatch || eqlDelimMatch || noDelimMatch) &&
                            !matchedIndices.has(idx));
                    });
                    // If not found, that means the given value was associated with the
                    // `flag` incorrectly. In that case, we move it from `flags` either
                    // to `args` or `argv in the parsed output.
                    if (flagIdx === -1) {
                        values.splice(i, 1);
                        i -= 1; // compensate for the .splice() call above
                        // check if there are args that are not defined yet
                        const firstUnsetArg = orderedArgNames.find(arg => parsed.args[arg] === undefined);
                        if (firstUnsetArg) {
                            // move the value to args
                            parsed.args[firstUnsetArg] = value;
                        }
                        else {
                            // move the value to argv
                            parsed.argv.push(value);
                        }
                    }
                    else {
                        matchedIndices.add(flagIdx);
                    }
                }
            }
        };
        // 2. massage the default `parse()` output:
        // Make sure the multi-value flags are parsed correctly
        multiValueFlagNames.forEach(fixFlag);
        // 3. validate the modified `parse()` output
        // Validation is the last step of the default `parse()` method.
        // Here we run it explicitly (again), but this time with unmodified args
        // definitions to make sure all required args have values.
        //
        // (this code block is copied from @oclif/core/lib/parser/index.js)
        const input = {
            argv,
            context: options.context || this,
            '--': options['--'],
            flags,
            args,
            strict: options.strict !== false,
        };
        await (0, validate_1.validate)({ input, output: parsed });
        return parsed;
    }
}
exports.ZenCommand = ZenCommand;
_a = ZenCommand;
ZenCommand.flags = {
    help: core_1.Flags.help({
        char: 'h',
        description: 'Show CLI help',
    }),
    'non-interactive': core_1.Flags.boolean({
        description: 'Disable all interactive prompts',
        default: async () => {
            if (process.env.STEPZEN_INTERACTIVE !== undefined) {
                return process.env.STEPZEN_INTERACTIVE.toLowerCase() === 'false';
            }
            return !process.stdin.isTTY || !process.stdout.isTTY;
        },
    }),
};
exports.default = ZenCommand;
//# sourceMappingURL=zen-command.js.map
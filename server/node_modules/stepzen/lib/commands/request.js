"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
// This file contains the code for the `stepzen request` command.
// The request command sends a GraphQL request to the StepZen endpoint
// in the current / given StepZen workspace.
// The endpoint needs to be deployed first for this command to work.
const chalk = require("chalk");
const debug = require("debug");
const fs = require("fs");
const core_1 = require("@oclif/core");
const errors_1 = require("@oclif/core/lib/errors");
const graphql_ws_1 = require("graphql-ws");
const graphql_1 = require("graphql");
const ws_1 = require("ws");
const sdk_1 = require("@stepzen/sdk");
const prettyMilliseconds = require("pretty-ms");
const stepzen_sdk_1 = require("../shared/stepzen-sdk");
const zen_command_1 = require("../shared/zen-command");
const constants_1 = require("../shared/constants");
const utils_1 = require("../shared/utils");
const request_variables_parser_1 = require("../shared/request-variables-parser");
const header_1 = require("../shared/header");
// Errors that have a `path` are specific to particular fields of the query.
// Errors that do NOT have a `path` are about the query as a whole.
// The former as considered "business as usual", the latter are "severe" and
// should be flagged as errors to the user.
const hasSevereError = (errors) => {
    return errors.some(error => error.path === undefined);
};
const formatErrorMessage = (errors) => {
    if (/Syntax Error GraphQL request/i.test(errors?.[0]?.message)) {
        // Special case: in this case the error message also contains the
        // (line:column) marker and a fragment from the original query.
        // It does not look good with the errors.map.join pattern below.
        return errors[0].message;
    }
    return ('Errors returned by the GraphQL server:\n' +
        errors
            .map(({ message, locations }) => ' - ' +
            (locations
                ? locations.map(sl => `(${sl.line}:${sl.column})`).join(' ') + ' '
                : '') +
            message)
            .join('\n'));
};
class Request extends zen_command_1.default {
    async run() {
        const { args, flags } = await this.parse(Request);
        const query = this.getRequestQuery(args.query, flags.file);
        const operation = this.getRequestOperation(query, flags['operation-name']);
        const variables = this.getRequestVariables(operation, flags.var, flags['var-file']);
        const customHeaders = this.getAdditionalRequestHeaders(flags.header);
        // Make sure the user is logged in
        const { configuration } = await this.ensureStepZenAccount({
            nonInteractive: flags['non-interactive'],
        });
        const zenserv = (0, constants_1.getZenServUrl)(configuration);
        let endpoint = flags.endpoint;
        if (!endpoint) {
            // Get the StepZen workspace from the given directory (or the current directory)
            const workspace = await this.ensureStepZenWorkspace({
                directory: flags.dir,
                silent: true,
                nonInteractive: true,
            });
            endpoint = workspace.endpoint;
        }
        const { result: userAgent } = await (0, stepzen_sdk_1.tryZenCtl2ThenZenCtl1)(configuration, stepzen => Promise.resolve(stepzen.userAgent));
        const headers = {
            authorization: `APIKey ${configuration.adminkey}`,
            'user-agent': userAgent,
            ...customHeaders.added,
        };
        customHeaders.removed.forEach(header => delete headers[header]);
        try {
            if (operation.operation === 'subscription') {
                const url = `${zenserv}/stepzen-subscriptions/${endpoint}/__graphql`.replace(/^http/i, 'ws');
                const client = (0, graphql_ws_1.createClient)({
                    webSocketImpl: ws_1.WebSocket,
                    url,
                    connectionParams: () => {
                        return {
                            headers,
                        };
                    },
                });
                const result = await new Promise((resolve, reject) => {
                    let count = 0;
                    let lastTimestamp = new Date().getTime();
                    let lastResult;
                    const payload = {
                        query,
                        variables,
                        operationName: flags['operation-name'],
                    };
                    debug('stepzen:request')(`opening a web socket connection to ${url}` +
                        `\nheaders: ${JSON.stringify(headers, undefined, 2)}` +
                        `\npayload: ${JSON.stringify(payload, undefined, 2)}`);
                    client.subscribe(payload, {
                        next: result => {
                            if (count === 0) {
                                // Avoid printing this message before the first non-error response
                                this.log(chalk `Subscribed to {bold ${url}}`);
                            }
                            const timestamp = new Date().getTime();
                            const elapsed = prettyMilliseconds(timestamp - lastTimestamp);
                            lastTimestamp = timestamp;
                            lastResult = result;
                            count += 1;
                            this.log(chalk `{grey event #${count} ({cyan +${elapsed}})}`);
                            const prefix = chalk.grey(`${count} | `);
                            this.log((0, utils_1.prependEachLine)(JSON.stringify(result, undefined, 2), prefix));
                        },
                        error: (error) => {
                            if (error?.error instanceof Error) {
                                // a web socket connection issue
                                reject(error.error);
                            }
                            else if (Array.isArray(error) &&
                                error.every(e => 'message' in e)) {
                                // graphql error
                                const errors = error;
                                reject(new Error(formatErrorMessage(errors)));
                            }
                            else {
                                reject(new Error(JSON.stringify(error)));
                            }
                        },
                        complete: () => {
                            this.log('Subscription completed: end of the event stream.');
                            resolve(lastResult);
                        },
                    });
                });
                if (!result || result.errors) {
                    this.exit(1);
                }
            }
            else {
                const result = await (0, sdk_1.fetchGraphQLQuery)({
                    url: `${zenserv}/${endpoint}/__graphql`,
                    query: query,
                    variables,
                    operationName: flags['operation-name'],
                    headers,
                });
                if (result.errors && hasSevereError(result.errors)) {
                    throw new Error(formatErrorMessage(result.errors));
                }
                this.log(JSON.stringify(result, undefined, 2));
            }
        }
        catch (error) {
            if (error instanceof errors_1.CLIError) {
                throw error;
            }
            let message = `Failed to execute the GraphQL query\n${'message' in error ? error.message : error}`;
            if (`${error}`.match(/Unexpected HTTP status 4\d+/i)) {
                message += chalk `\n\nDid you run {bold stepzen deploy} to deploy your endpoint?`;
            }
            throw new errors_1.CLIError(message);
        }
    }
    getRequestQuery(queryArg, queryFlag) {
        if (!queryArg && !queryFlag) {
            throw new errors_1.CLIError(chalk `Please provide a query either directly on the command line` +
                chalk ` with the {bold QUERY} argument, or through a file with the` +
                chalk ` {bold -f, --file} flag.`);
        }
        if (queryArg && queryFlag) {
            throw new errors_1.CLIError(chalk `Unexpected flag {bold -f, --file}={underline ${queryFlag}}.` +
                chalk ` Could not handle both the {bold QUERY} argument and the` +
                chalk ` {bold -f, --file} flag. Please remove one.`);
        }
        if (queryArg) {
            return queryArg;
        }
        try {
            return fs.readFileSync(queryFlag, { encoding: 'utf-8' });
        }
        catch (error) {
            throw new errors_1.CLIError(chalk `Could not read the query from ${queryFlag}.\n${error}`);
        }
    }
    getRequestOperation(query, operationName) {
        let parsedQuery;
        try {
            parsedQuery = (0, graphql_1.parse)(query);
        }
        catch (error) {
            throw new errors_1.CLIError(`Failed to parse the GraphQL query\n${error}`);
        }
        const operations = parsedQuery.definitions.filter(node => node.kind === 'OperationDefinition');
        if (operations.length === 0) {
            throw new errors_1.CLIError(`Please provide a GraphQL request with at least one operation:` +
                ` query, mutation or subscription.`);
        }
        if (operationName) {
            const operation = operations.find(odn => odn.name?.value === operationName);
            if (!operation) {
                throw new errors_1.CLIError(chalk `Operation {bold ${operationName}} is not defined in the provided request.`);
            }
            return operation;
        }
        if (operations.length > 1) {
            throw new errors_1.CLIError(chalk `The request contains multiple operations, but the operation` +
                chalk ` name is not provided. Please provide an operation name with` +
                chalk ` the {bold --operation-name} flag, or remove all other` +
                chalk ` operations except the intended one from the request.`);
        }
        return operations[0];
    }
    getRequestVariables(opdef, variableFlags, varFileFlag) {
        let varFile = {};
        if (varFileFlag) {
            try {
                varFile = JSON.parse(fs.readFileSync(varFileFlag, 'utf8'));
            }
            catch (error) {
                throw new errors_1.CLIError(`Cannot read request variables from ${varFileFlag}.\n${error}`);
            }
        }
        const { variables: flagVariables, errors } = (0, request_variables_parser_1.parseRequestVariables)(variableFlags || [], opdef, varFile);
        if (errors.length > 0) {
            const msg = variableFlags?.length || varFileFlag
                ? 'Could not resolve request variables'
                : 'Missing request variables';
            throw new errors_1.CLIError(chalk `${msg}\n  - ` + errors.join('\n  - '));
        }
        return {
            ...varFile,
            ...flagVariables,
        };
    }
    getAdditionalRequestHeaders(headerFlagValues) {
        const added = {};
        const removed = [];
        if (headerFlagValues) {
            headerFlagValues.forEach(headerFlag => {
                const { result: header, error } = (0, header_1.parseHeader)(headerFlag);
                if (error) {
                    throw new errors_1.CLIError(error.message);
                }
                // A `null` from parseHeader() means a header should NOT be sent.
                if (!header) {
                    const name = headerFlag.substring(0, headerFlag.length - 1);
                    removed.push(name.toLowerCase());
                    return;
                }
                const name = header.name.toLowerCase();
                const value = header.value;
                // Combine repeated headers into one
                // https://stackoverflow.com/questions/3096888
                added[name] = added[name] ? `${added[name]},${value}` : value;
            });
        }
        return {
            added,
            removed,
        };
    }
}
exports.default = Request;
Request.description = `Send a GraphQL request to a StepZen endpoint and print the response,` +
    ` using the API key and the target endpoint from the current StepZen` +
    ` workspace.`;
Request.flags = {
    ...zen_command_1.default.flags,
    dir: core_1.Flags.string({
        description: 'StepZen workspace directory (defaults to the current directory)',
        exclusive: ['endpoint'],
    }),
    endpoint: core_1.Flags.string({
        description: 'StepZen endpoint to call (defaults to the endpoint in current StepZen workspace)',
        exclusive: ['dir'],
    }),
    header: core_1.Flags.string({
        char: 'H',
        description: chalk `Add an additional HTTP header to the request.` +
            chalk ` This is useful for schemas where {bold @rest} or {bold @graphql}` +
            chalk ` directives enable header forwarding with {bold forwardheaders}.` +
            `\n` +
            `\nExample:` +
            `\nstepzen request '{ user(id: "u123") { email } }' \\` +
            `\n\t-H "X-API-Token: SecretAPIToken"` +
            `\n` +
            chalk `\nUse the {bold -H "Header-Name:"} syntax to drop a default` +
            chalk ` header, and the {bold -H "Header-Name;"} syntax to send a` +
            ` header with an empty value.`,
        multiple: true,
    }),
    'operation-name': core_1.Flags.string({
        description: chalk `Specify the operation name (in case if the provided query includes multiple operations)`,
    }),
    var: core_1.Flags.string({
        description: chalk `Add a request variable, in the {bold name}={underline value} format.` +
            `\n` +
            `\nExample:` +
            `\nstepzen request 'query OrdersQuery($search: String!, $limit: Int) {` +
            `\n\t\torders(search: $search, limit: $limit) { id createdAt }` +
            `\n\t}' \\` +
            `\n\t--var 'search=space ninja' \\` +
            `\n\t--var limit=5`,
        multiple: true,
    }),
    'var-file': core_1.Flags.string({
        description: chalk `Read request variables from a JSON file. In case when the same` +
            chalk ` variable value is provided both via {bold --var-file} and` +
            chalk ` {bold --var}, the priority is given to the latter.` +
            `\n` +
            `\nExample:` +
            `\nstepzen request 'query OrdersQuery($search: String!, $limit: Int) {` +
            `\n\t\torders(search: $search, limit: $limit) { id createdAt }` +
            `\n\t}' \\` +
            `\n\t--var-file ./vars.json`,
    }),
    file: core_1.Flags.string({
        char: 'f',
        description: chalk `Read the query text from a file instead of the command line.` +
            `\n` +
            `\nExample:` +
            `\nstepzen request -f query.graphql`,
    }),
};
Request.args = {
    query: core_1.Args.string({
        description: 'GraphQL query (could include a query, a mutation or a subscription).' +
            chalk `\nThis argument is required unless you provide the query as a file with {bold --file}={underline file}.`,
    }),
};
//# sourceMappingURL=request.js.map
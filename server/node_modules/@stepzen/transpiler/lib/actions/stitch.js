"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const graphql_1 = require("graphql");
const fsx = require("fs-extra");
const glob = require("glob");
const os = require("os");
const path = require("path");
const prettier = require("prettier");
const dedupe_query_and_mutation_types_1 = require("../utils/dedupe-query-and-mutation-types");
const constants_1 = require("../utils/constants");
const copy_workspace_content_1 = require("../utils/copy-workspace-content");
const rmtemp_1 = require("../utils/rmtemp");
const doStitch = (source, output) => {
    // Ensure source and output directories exist
    if (!fsx.existsSync(source))
        throw new Error(`Cannot find source directory ${source}`);
    fsx.ensureDirSync(output, 0o700);
    // Get a list of files.
    let ast;
    let files = [];
    // If there's an index.graphQL - get files argument in @sdl directive
    const sourceIndex = path.join(source, 'index.graphql');
    if (fsx.existsSync(sourceIndex)) {
        const index = fsx.readFileSync(sourceIndex, 'utf8');
        ast = (0, graphql_1.parse)(index);
        ast = (0, graphql_1.visit)(ast, {
            Directive(node) {
                if (node.name.value === 'sdl') {
                    const list = node.arguments?.find((arg) => arg.name.value === 'files');
                    // If we find a 'files' argument, we copy the list, and remove the argument
                    if (list) {
                        const copy = (0, lodash_1.clone)(list.value);
                        for (const file of copy.values) {
                            if (file.value === constants_1.ALL_GRAPHQL_FILES) {
                                files = files.concat((0, copy_workspace_content_1.getAllGraphQLFiles)(source));
                            }
                            else {
                                files = files.concat(file.value);
                            }
                        }
                        const mutated = (0, lodash_1.cloneDeep)(node);
                        mutated.arguments = mutated.arguments.filter((arg) => arg.name.value !== 'files');
                        return mutated;
                    }
                }
            },
        });
    }
    else {
        const content = glob
            .sync('**/*.graphql', { cwd: source })
            .map((file) => {
            const graphql = fsx.readFileSync(`${source}/${file}`, 'utf8');
            return graphql;
        });
        ast = (0, graphql_1.parse)(content.join(os.EOL));
    }
    // Strip @sdl directive
    ast = (0, graphql_1.visit)(ast, {
        Directive(node) {
            if (node.name.value === 'sdl')
                return null;
        },
    });
    // Check all the files exist
    for (const file of files) {
        const find = path.join(source, file);
        if (!fsx.existsSync(find)) {
            throw new Error(`Cannot find file ${file} referenced in the @sdl directive in index.graphql`);
        }
    }
    // Get all the files and stitch
    const printed = (0, graphql_1.print)(ast);
    let stitched = `${printed}${os.EOL}`;
    for (const file of files) {
        const find = path.join(source, file);
        const content = fsx.readFileSync(find, 'utf8');
        stitched += `${content}${os.EOL}`;
    }
    // Dedupe Query and Mutation types
    stitched = (0, dedupe_query_and_mutation_types_1.default)(stitched);
    // Format
    stitched = prettier.format(stitched, { parser: 'graphql' });
    // Write to output folder
    const outputIndex = path.join(output, 'index.graphql');
    fsx.writeFileSync(outputIndex, stitched);
    // Copy config if exists, too
    const sourceConfig = path.join(source, 'config.yaml');
    const outputConfig = path.join(output, 'config.yaml');
    if (fsx.existsSync(sourceConfig)) {
        fsx.copyFileSync(sourceConfig, outputConfig);
    }
    // Return output folder
    return output;
};
const stitch = (source, output) => {
    if (output) {
        return doStitch(source, output);
    }
    output = path.join(os.tmpdir(), `stepzen-tmp-${Date.now()}`);
    try {
        return doStitch(source, output);
    }
    catch (error) {
        // In case of an error delete the temp output folder created earlier so that
        // it does not "leak". In case of a success, deleting the output folder is
        // the caller responsibility.
        (0, rmtemp_1.rmtemp)(output);
        throw error;
    }
};
exports.default = stitch;
//# sourceMappingURL=stitch.js.map
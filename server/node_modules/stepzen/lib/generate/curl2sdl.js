"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeDuplicateParamsMessage = exports.compileParameterList = exports.curl2sdl = void 0;
const chalk = require("chalk");
const lodash_1 = require("lodash");
const constants_1 = require("../shared/constants");
const helpers_1 = require("./helpers");
const curl2sdl = async ({ curlArgs, queryName, rootType, typePrefix, pathParams, headers, }, configuration) => {
    const { result, error } = await (0, helpers_1.queryIntrospectionService)((0, constants_1.getIntrospectionUrl)(configuration), {
        operation: 'getSDLFromCurl',
        variables: {
            command: {
                type: 'String!',
                value: curlArgs.url,
            },
            queryName: {
                type: 'String',
                value: queryName || null,
            },
            rootType: {
                type: 'String',
                value: rootType || null,
            },
            typePrefix: {
                type: 'String',
                value: typePrefix || null,
            },
            headers: {
                type: '[HeaderInput!]',
                value: headers && headers.length > 0 ? headers : null,
            },
            data: {
                type: 'String',
                value: curlArgs.data || null,
            },
            method: {
                type: 'HTTPMethod!',
                value: curlArgs.method,
            },
            pathParams: {
                type: '[PathParamInput!]',
                value: pathParams.length > 0 ? pathParams : null,
            },
        },
    });
    if (error) {
        return error.message.includes('Query was interrupted after timeout')
            ? {
                error: {
                    message: 'The StepZen REST introspection service has timed out.',
                },
            }
            : { error };
    }
    return { result };
};
exports.curl2sdl = curl2sdl;
/**
 * Collect together all query parameters from HTTP headers and from the
 * pathname, and return them as a uniform list.
 *
 * @param {*} headers list of curl headers, possibly with parameters
 * @param {*} pathParams list of path parameters
 * @param {*} pathname full pathname of the REST endpoint
 * @returns {*} combined list of query parameters in a uniform format
 */
const compileParameterList = (headers, pathParams, pathname) => {
    // Drop empty segments, including empty string before the leading slash
    const pathSegments = pathname.split('/').filter(Boolean);
    // For each header, make a list of the parameters it contains.
    // `flatMap()` concatenates each header's param lists into a single list.
    return (0, lodash_1.flatMap)(headers, header => {
        // skip headers that don't contain parameters
        if (!('parts' in header)) {
            return [];
        }
        // Reconstruct the full header string (for the context).
        const fullHeader = `${header.name}: ${header.parts
            .map(part => part.value)
            .join('')}`;
        // Filter out the 'Variable' parts of the header value, and convert them
        // to the `CurlyQueryParameter` structure.
        return header.parts
            .map(part => part.kind === 'Variable'
            ? {
                name: part.name,
                value: part.value,
                context: `'${header.name}' header ${chalk.dim(`(${fullHeader})`)}`,
            }
            : null)
            .filter(Boolean); // remove nulls
    }).concat(
    // Append the path parameters to the list, converting them to
    // the `CurlyQueryParameter` structure as well.
    pathParams.map(param => ({
        name: param.name,
        value: pathSegments[param.index],
        context: `pathname ${chalk.dim(`(${pathname})`)}`,
    })));
};
exports.compileParameterList = compileParameterList;
/**
 * Check the header and path parameters for duplicates, and construct a
 * user-friendly error message describing identified problems (if any).
 * If no problems are found, return `null`.
 *
 * @param {*} headers list of curl headers, possibly with parameters
 * @param {*} pathParams list of path parameters
 * @param {*} url full URL of the REST endpoint
 * @returns {*} a message describing duplicate query parameters, or null if
 *              there are no duplicates
 */
const makeDuplicateParamsMessage = (headers, pathParams, url) => {
    // Create a uniform list of query parameters from the headers and path
    const parameters = (0, exports.compileParameterList)(headers, pathParams, new URL(url).pathname);
    const errors = Object.entries((0, lodash_1.groupBy)(parameters, 'name'))
        // Create groups for each unique parameter name,
        // and then sub-groups for each unique [name, value] tuple.
        .map(([name, group]) => ({
        name,
        values: Object.entries((0, lodash_1.groupBy)(group, 'value')),
    }))
        // ignore the [name, value] tuples that occur only once
        .filter(({ values }) => values.length > 1)
        // for the rest, create a message describing the duplicates
        .map(({ name, values }) => `The parameter ${chalk.bold(`$${name}`)} is used for ${values.length} different values:` +
        `\n${values
            .map(([value, params], i) => `\t${i + 1}: '${value}' in the ${params[0].context}`)
            .join('\n')}`);
    if (errors.length > 0) {
        return ('Could not use the same name for different parameters.\n' +
            errors.join('\n') +
            '\nPlease give a different parameter name for each variable value.');
    }
    return null;
};
exports.makeDuplicateParamsMessage = makeDuplicateParamsMessage;
//# sourceMappingURL=curl2sdl.js.map
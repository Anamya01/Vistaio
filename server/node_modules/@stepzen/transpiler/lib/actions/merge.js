"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
const fsx = require("fs-extra");
const glob = require("glob");
const merge_1 = require("@graphql-tools/merge");
const graphql_1 = require("graphql");
const os = require("os");
const path = require("path");
const yaml = require("yaml");
const merge_helpers_1 = require("../utils/merge-helpers");
const print_1 = require("./print");
const set_files_in_sdl_1 = require("../utils/set-files-in-sdl");
const strip_empty_queries_and_mutations_1 = require("../utils/strip-empty-queries-and-mutations");
const copy_workspace_content_1 = require("../utils/copy-workspace-content");
const constants_1 = require("../utils/constants");
const rmtemp_1 = require("../utils/rmtemp");
// It's safe to use this special placeholder value here: in case of a failure
// in the merge / import process it will not reach the workspace folder.
// All intermediary steps are carried out in a temp folder, and only when all
// merge / import steps are completed, the result it copied over to the
// workspace folder.
const BLANK_INDEX_TEMPLATE = `
schema @sdl(files: ["${constants_1.ALL_GRAPHQL_FILES}"]) {
  query: Query
}
`.trim();
const BLANK_QUERY_TYPE = `
type Query {
  __query: String
}
`.trim();
const doMerge = async (original, imported, options) => {
    if (!options.answers)
        options.answers = {};
    if (!options.silent)
        options.silent = false;
    if (options.mergeTypes === undefined)
        options.mergeTypes = true;
    if (options.onConflict === undefined)
        options.onConflict = 'append';
    if (!options.extensions)
        options.extensions = await (0, merge_helpers_1.getExtensions)();
    // To stop things like
    // C:\Users\Darren\AppData\Local\Temp\stepzen-tmp-config-1638293497187\C:\Users\Darren\AppData\Local\Temp\stepzen-tmp-1638293496286
    options.output = (0, merge_helpers_1.dedupeTempFolder)(options.output);
    // Ensure original, importing and output directories exist
    if (!fsx.existsSync(original))
        throw new Error(`Cannot find original directory ${original}`);
    if (!fsx.existsSync(imported.source))
        throw new Error(`Cannot find imported source directory ${imported.source}`);
    fsx.ensureDirSync(options.output, 0o700);
    // Copy the original into the output.
    (0, copy_workspace_content_1.default)(original, options.output);
    // Ensure an index.graphql exists
    const outputIndex = path.join(options.output, 'index.graphql');
    if (!fsx.existsSync(outputIndex)) {
        fsx.writeFileSync(outputIndex, options.mergeTypes
            ? // (2022-03-09, vluakshov) Not sure what'd break without the
                // blank Query type, but that's why I do not want to remove it
                // from the default code path.
                BLANK_INDEX_TEMPLATE + BLANK_QUERY_TYPE
            : // In the non-default code path that does NOT merge types
                // the blank Query type causes explicit problems
                // (https://github.com/steprz/stepzen-cli/issues/482).
                BLANK_INDEX_TEMPLATE);
    }
    const targetSubfolder = options.onConflict === 'overwrite'
        ? imported.name
        : (0, merge_helpers_1.findNextAvailableSubfolder)(original, imported.name);
    let importedGraphQLFiles = [];
    if (options.mergeTypes) {
        const merged = (0, merge_1.mergeTypeDefs)([
            await (0, merge_helpers_1.getSchema)(options.output, options.extensions),
            await (0, merge_helpers_1.getSchema)(imported.source, options.extensions),
        ]);
        let queries = [];
        let mutations = [];
        let types = [];
        (0, graphql_1.visit)(merged, {
            ObjectTypeDefinition(node) {
                if (node.name.value === 'Query')
                    queries = queries.concat(node.fields);
                else if (node.name.value === 'Mutation')
                    mutations = mutations.concat(node.fields);
                else
                    types = types.concat(node);
            },
        });
        const details = {
            original: glob.sync('**/*.graphql', { cwd: options.output }).map(file => {
                const content = fsx.readFileSync(`${options.output}/${file}`, 'utf8');
                return { ast: (0, graphql_1.parse)(content), file };
            }),
            imported: glob.sync('**/*.graphql', { cwd: imported.source }).map(file => {
                const content = fsx.readFileSync(`${imported.source}/${file}`, 'utf8');
                return { ast: (0, graphql_1.parse)(content), file };
            }),
        };
        // Merge Queries and Mutations
        for (const type of [...queries, ...mutations]) {
            const isInOriginal = (0, merge_helpers_1.findQueryMutationInSchema)(type.name.value, details.original);
            const isInImported = (0, merge_helpers_1.findQueryMutationInSchema)(type.name.value, details.imported);
            if (isInOriginal && isInImported) {
                details.original = (0, merge_helpers_1.mergeQueryMutationIntoSchema)(type, details.original);
                details.imported = (0, merge_helpers_1.removeQueryMutationFromSchema)(type.name.value, details.imported);
            }
        }
        // Merge Types
        for (const type of types) {
            const isInOriginal = (0, merge_helpers_1.findTypeInSchema)(type.name.value, details.original);
            const isInImported = (0, merge_helpers_1.findTypeInSchema)(type.name.value, details.imported);
            if (isInOriginal && isInImported) {
                details.original = (0, merge_helpers_1.mergeTypeIntoSchema)(type, details.original);
                details.imported = (0, merge_helpers_1.removeTypeFromSchema)(type.name.value, details.imported);
            }
        }
        // Clean up the files. Remove empty Query / Mutation types, filter out now-empty files
        const cleaned = {
            original: details.original
                .map(item => ({
                ...item,
                ast: (0, strip_empty_queries_and_mutations_1.default)(item.ast),
            }))
                .filter(item => item.ast.definitions.length > 0),
            imported: details.imported
                .map(item => ({
                ...item,
                ast: (0, strip_empty_queries_and_mutations_1.default)(item.ast),
            }))
                .filter(item => item.ast.definitions.length > 0),
        };
        // Write the files to the output directory
        cleaned.original.forEach((a) => {
            // eslint-disable-next-line
            const file = path.join(options.output, a.file);
            const deduped = (0, merge_helpers_1.dedupeTempFolder)(file);
            fsx.ensureFileSync(deduped);
            fsx.writeFileSync(deduped, (0, print_1.default)(a.ast));
        });
        cleaned.imported.forEach(a => {
            // eslint-disable-next-line
            const file = path.join(options.output, targetSubfolder, a.file);
            const deduped = (0, merge_helpers_1.dedupeTempFolder)(file);
            fsx.ensureFileSync(deduped);
            fsx.writeFileSync(deduped, (0, print_1.default)(a.ast));
            importedGraphQLFiles.push(path.relative(options.output, deduped));
        });
    }
    else {
        glob.sync('**/*.graphql', { cwd: imported.source }).forEach(relativePath => {
            const importedFullPath = path.join(imported.source, relativePath);
            const targetFullPath = path.join(options.output, targetSubfolder, relativePath);
            fsx.ensureDirSync(path.dirname(targetFullPath));
            fsx.copyFileSync(importedFullPath, targetFullPath);
            importedGraphQLFiles.push(path.relative(options.output, targetFullPath));
        });
    }
    // Make sure all files are referenced in @sdl
    (0, set_files_in_sdl_1.default)(options.output, importedGraphQLFiles);
    // Generate configuration
    const config = await (0, merge_helpers_1.getConfiguration)([options.output, imported.source], options.silent, options.answers);
    if (config) {
        const configFile = path.join(options.output, 'config.yaml');
        fsx.writeFileSync(configFile, yaml.stringify(config), { mode: 0o600 });
    }
    // Return a merged schema!
    return options.output;
};
const merge = (original, imported, options = {
    answers: {},
    output: null,
    silent: false,
    mergeTypes: true,
    onConflict: 'append',
    extensions: '',
}) => {
    // Make sure there is an output directory
    if (options.output) {
        return doMerge(original, imported, options);
    }
    const output = path.join(os.tmpdir(), `stepzen-tmp-${Date.now()}`);
    try {
        return doMerge(original, imported, { ...options, output });
    }
    catch (error) {
        // In case of an error delete the temp output folder created earlier so that
        // it does not "leak". In case of a success, deleting the output folder is
        // the caller responsibility.
        (0, rmtemp_1.rmtemp)(output);
        throw error;
    }
};
exports.default = merge;
//# sourceMappingURL=merge.js.map
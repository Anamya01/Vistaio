{"version":3,"sources":["../src/dsn-parser.type.ts","../src/dsn-parser.util.ts","../src/query-param-parser.ts","../src/parse-dsn.ts","../src/parse-dsn-or-throw.ts","../src/assert-parsable-dsn.ts","../src/is-parsable-dsn.ts"],"sourcesContent":["export type ParsedDsn = {\n  driver: string;\n  host: string;\n  user?: string;\n  pass?: string;\n  port?: number;\n  db?: string;\n  /** Query params */\n  params?: Record<string, number | string | boolean>;\n};\n\nexport type ParseDsnOptions = {\n  /** Whether to lowercase parsed driver name, default: false */\n  lowercaseDriver?: boolean;\n  /** Overrides parsed values by those one (except query params) */\n  overrides?: Omit<Partial<ParsedDsn>, 'params'>;\n};\n\nexport const errorReasons = {\n  EMPTY_DSN: 'DSN cannot be empty',\n  INVALID_ARGUMENT: 'DSN must be a string',\n  PARSE_ERROR: 'Cannot parse DSN',\n  INVALID_PORT: 'Invalid port',\n} as const;\n\nexport type ErrorReasons = keyof typeof errorReasons;\n\ntype ParserSuccessResult = {\n  success: true;\n  value: ParsedDsn;\n};\n\nexport type ParserErrorResult = {\n  success: false;\n  reason: ErrorReasons;\n  message: string;\n};\n\nexport type ParserResult = ParserSuccessResult | ParserErrorResult;\n\nexport type ParsableDsn = string;\n","import type {\n  ParsedDsn,\n  ParseDsnOptions,\n  ErrorReasons,\n  ParserErrorResult,\n} from './dsn-parser.type';\nimport { errorReasons } from './dsn-parser.type';\n\nexport const createErrorResult = (\n  reason: ErrorReasons,\n  msg?: string\n): ParserErrorResult => {\n  return {\n    success: false,\n    reason: reason,\n    message: msg || errorReasons[reason],\n  };\n};\n\nexport const isNonEmptyString = (\n  value: unknown,\n  trim = true\n): value is string => {\n  return typeof value === 'string' && (trim ? value.trim() : value).length > 0;\n};\n\nexport const isParsableNumber = (value: unknown): value is number => {\n  return typeof value === 'string' && /^-?\\d{1,16}$/.test(value);\n};\n\nexport const isValidNetworkPort = (port: number): port is number => {\n  return port < 65536 && port > 0;\n};\n\nexport const removeUndefined = (\n  obj: Record<string, unknown>\n): Record<string, unknown> => {\n  return Object.keys(obj).reduce<Record<string, unknown>>((acc, key) => {\n    if (obj[key] !== undefined) acc[key] = obj[key];\n    return acc;\n  }, {});\n};\n\nexport const mergeDsnOverrides = (\n  parsedDsn: ParsedDsn,\n  overrides: Exclude<ParseDsnOptions['overrides'], undefined>\n): ParsedDsn => {\n  const merged: Record<string, unknown> = {};\n  const { params, ...restDsn } = parsedDsn;\n  Object.entries(restDsn).forEach(([key, value]) => {\n    merged[key] =\n      key in overrides ? (overrides as Record<string, unknown>)[key] : value;\n  });\n  merged['params'] = params;\n  return merged as unknown as ParsedDsn;\n};\n","import { isParsableNumber } from './dsn-parser.util';\n\ntype ParseQueryParamsOptions = {\n  setTrueForUndefinedValues?: boolean;\n  parseBooleans?: boolean;\n  parseNumbers?: boolean;\n};\n\nconst defaultOptions = {\n  setTrueForUndefinedValues: true,\n  parseBooleans: true,\n  parseNumbers: true,\n};\n\nexport const parseQueryParams = (\n  queryParams: string,\n  options?: ParseQueryParamsOptions\n): Record<string, string | boolean | number | null> => {\n  const { parseBooleans, setTrueForUndefinedValues, parseNumbers } = {\n    ...defaultOptions,\n    ...(options || {}),\n  };\n  const defaultValue = setTrueForUndefinedValues ? true : null;\n  const parts = queryParams.split('&').filter((v) => v.trim().length > 0);\n  return parts.reduce((acc, keyValuePair) => {\n    const [key, value = null] = keyValuePair.split('=');\n    let val;\n    if (typeof value === 'string') {\n      if (parseNumbers && isParsableNumber(value)) {\n        val = Number.parseInt(value, 10);\n      } else {\n        val =\n          parseBooleans && ['true', 'false'].includes(value)\n            ? value === 'true'\n            : decodeURIComponent(value);\n      }\n    } else {\n      val = defaultValue;\n    }\n    return { ...acc, ...{ [key]: val } };\n  }, {});\n};\n","import type {\n  ParsedDsn,\n  ParseDsnOptions,\n  ParserResult,\n} from './dsn-parser.type';\nimport {\n  createErrorResult,\n  isNonEmptyString,\n  isValidNetworkPort,\n  mergeDsnOverrides,\n  removeUndefined,\n} from './dsn-parser.util';\nimport { parseQueryParams } from './query-param-parser';\n\nconst dsnRegexp =\n  /^(?<driver>([\\w-]+)):\\/\\/((?<user>[^/:]{1,200})?(:(?<pass>.{0,250}))?@)?(?<host>[^/:]{1,400}?)(:(?<port>\\d+)?)?(\\/(?<db>([.#@$\\w-])+))?(\\?(?<params>.+))?$/;\n\nconst defaultOptions = {\n  lowercaseDriver: false,\n  overrides: {},\n};\n\nexport const parseDsn = (\n  dsn: unknown,\n  options?: ParseDsnOptions\n): ParserResult => {\n  if (!isNonEmptyString(dsn)) {\n    return createErrorResult(\n      typeof dsn !== 'string' ? 'INVALID_ARGUMENT' : 'EMPTY_DSN'\n    );\n  }\n  const opts = { ...defaultOptions, ...(options || {}) };\n  const { overrides = {}, lowercaseDriver } = opts;\n  const matches = dsn.match(dsnRegexp);\n  if (matches === null || !matches.groups) {\n    return createErrorResult('PARSE_ERROR');\n  }\n  const parsed: Record<string, unknown> = {};\n  Object.entries(matches.groups).forEach(([key, value]) => {\n    if (typeof value === 'string') {\n      switch (key) {\n        case 'driver':\n          parsed['driver'] = lowercaseDriver ? value.toLowerCase() : value;\n          break;\n        case 'port':\n          parsed['port'] = Number.parseInt(value, 10);\n          break;\n        case 'params':\n          parsed['params'] = parseQueryParams(value);\n          break;\n        default:\n          parsed[key] = value;\n      }\n    }\n  });\n  const val = removeUndefined(\n    mergeDsnOverrides(parsed as ParsedDsn, overrides)\n  ) as ParsedDsn;\n  if (val?.port && !isValidNetworkPort(val.port)) {\n    return createErrorResult('INVALID_PORT', `Invalid port: ${val.port}`);\n  }\n  return {\n    success: true,\n    value: val,\n  };\n};\n","import type { ParsedDsn, ParseDsnOptions } from './dsn-parser.type';\nimport { parseDsn } from './parse-dsn';\n\nexport const parseDsnOrThrow = (\n  dsn: unknown,\n  options?: ParseDsnOptions & {\n    errorMsgPrefix?: string;\n  }\n): ParsedDsn => {\n  const parsedOrError = parseDsn(dsn, options);\n  if (parsedOrError.success) {\n    return parsedOrError.value;\n  }\n  const pfx = options?.errorMsgPrefix ?? `Can't parse dsn`;\n  throw new Error(`${pfx}: ${parsedOrError.message} (${parsedOrError.reason})`);\n};\n","import type { ParsableDsn } from './dsn-parser.type';\nimport { parseDsn } from './parse-dsn';\n\n/**\n * @throws Error when not parsable\n */\nexport const assertParsableDsn = (\n  dsn: unknown,\n  msg?: string\n): asserts dsn is ParsableDsn => {\n  const parsed = parseDsn(dsn as string);\n  if (!parsed.success) {\n    throw new Error(msg || `${parsed.message} (${parsed.reason})`);\n  }\n};\n","import type { ParsableDsn } from './dsn-parser.type';\nimport { parseDsn } from './parse-dsn';\n\nexport const isParsableDsn = (dsn: unknown): dsn is ParsableDsn => {\n  const parsed = parseDsn(dsn as string);\n  return parsed.success;\n};\n"],"mappings":"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","names":["errorReasons","createErrorResult","reason","msg","errorReasons","isNonEmptyString","value","trim","isParsableNumber","isValidNetworkPort","port","removeUndefined","obj","acc","key","mergeDsnOverrides","parsedDsn","overrides","merged","_a","params","restDsn","__objRest","defaultOptions","parseQueryParams","queryParams","options","parseBooleans","setTrueForUndefinedValues","parseNumbers","__spreadValues","defaultValue","v","acc","keyValuePair","key","value","val","isParsableNumber","__spreadProps","dsnRegexp","defaultOptions","parseDsn","dsn","options","isNonEmptyString","createErrorResult","opts","__spreadValues","overrides","lowercaseDriver","matches","parsed","key","value","parseQueryParams","val","removeUndefined","mergeDsnOverrides","isValidNetworkPort","parseDsnOrThrow","dsn","options","_a","parsedOrError","parseDsn","pfx","assertParsableDsn","dsn","msg","parsed","parseDsn","isParsableDsn","dsn","parseDsn"]}
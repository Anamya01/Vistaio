"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const errors_1 = require("@oclif/core/lib/errors");
const errors_2 = require("@oclif/core/lib/parser/errors");
const chalk = require("chalk");
const string_argv_1 = require("string-argv");
const curl2sdl_1 = require("../../generate/curl2sdl");
const flags_1 = require("../../generate/flags");
const helpers_1 = require("../../generate/helpers");
const configuration_1 = require("../../shared/configuration");
const constants_1 = require("../../shared/constants");
const curl_parser_1 = require("../../shared/curl-parser");
const inquirer = require("../../shared/inquirer");
const path_params_parser_1 = require("../../shared/path-params-parser");
const utils_1 = require("../../shared/utils");
const import_command_1 = require("../../generate/import-command");
const questions_1 = require("../../generate/questions");
class ImportCurl extends import_command_1.ImportCommandBase {
    get source() {
        return 'curl';
    }
    async import(commonOptions) {
        const { flags, argv } = await this.parse(ImportCurl);
        const nonInteractiveOptions = {
            queryName: flags['query-name'],
            rootType: flags['query-type'],
            typePrefix: flags.prefix,
            pathParams: flags['path-params'],
            headers: (0, helpers_1.parseHeaderFlags)(flags.header, flags['header-param']),
        };
        let curl2sdlOptions;
        if (argv.length > 0) {
            // Non-empty argv means that the user has passed in a curl command
            //   => running non-interactively
            const { result: curlArgs, error: curlError } = (0, curl_parser_1.parseCurlArgv)(argv);
            if (curlError) {
                throw new errors_1.CLIError(curlError.message);
            }
            const { result: pathParams, error: pathParamsError } = (0, path_params_parser_1.parsePathParamsPattern)(curlArgs.url, flags['path-params']);
            if (pathParamsError) {
                throw new errors_1.CLIError(pathParamsError.message);
            }
            const maybeDuplicateParamsMessage = (0, curl2sdl_1.makeDuplicateParamsMessage)(nonInteractiveOptions.headers, pathParams, curlArgs.url);
            if (maybeDuplicateParamsMessage) {
                throw new errors_1.CLIError(maybeDuplicateParamsMessage);
            }
            curl2sdlOptions = {
                ...commonOptions,
                ...nonInteractiveOptions,
                pathParams,
                curlArgs,
            };
        }
        else {
            if (flags['non-interactive']) {
                throw new errors_1.CLIError('Please provide a REST endpoint URL or a full curl command.' +
                    chalk `\nSee more help with {bold stepzen import curl --help}`);
            }
            // no parameters given: start an interactive prompt
            if (!flags.silent) {
                this.log();
                this.log(chalk `{bold stepzen import curl} - ` +
                    chalk.dim('introspect a REST API endpoint and extend your GraphQL schema' +
                        ' with the types and a query field for accessing it through' +
                        chalk ` your StepZen API. The {bold {underline curl}} command` +
                        ' syntax is supported so that you can copy and paste a full' +
                        ' curl command instead of the URL.'));
                this.log();
            }
            const interactiveOptions = await this.getImportOptionsInteractively(nonInteractiveOptions);
            curl2sdlOptions = {
                ...commonOptions,
                ...interactiveOptions,
                // include boths headers passed via flags and headers entered interactively
                headers: [
                    ...nonInteractiveOptions.headers,
                    ...interactiveOptions.curlArgs.headers,
                ],
            };
        }
        const configuration = await (0, configuration_1.readConfiguration)();
        curl2sdlOptions.curlArgs.url = (0, utils_1.rewriteLocalhostToHostGatewayInURL)(configuration, curl2sdlOptions.curlArgs.url);
        const { result, error } = await this.wrapInProgressAndTimeout((0, curl2sdl_1.curl2sdl)(curl2sdlOptions, configuration));
        if (error) {
            return {
                error: {
                    message: 'Please check that the given curl command is valid.\n' +
                        error.message,
                },
            };
        }
        return { result };
    }
    // special parsing to support curl flags and options
    async parse(options, argv = this.argv) {
        try {
            const parsed = await super.parse(options, argv);
            // "unparse" the curl flags and args into the argv array
            // (to be parsed again by the curl-parser code later)
            //
            // The main reason for this non-optimal approach:
            //  - In StepZen CLI, a curl command parser with support for
            //    curl-specific validation and error messages has been historically
            //    implemented without using the oclif parser. (This was done
            //    because the curl syntax conventions for command line flags and
            //    options slightly differ from those in oclif.)
            //  - The custom curl parser is used in 2 places: to initially parse
            //    the command line when running the Import command, and also to
            //    parse the user answer to the "URL or a whole curl command"
            //    question in the `askCurlQuestions()` function.
            //  - The workarounds added to the oclif's `parse()` method in the
            //    ZenCommand base class make it feasible to use the customised
            //    oclif parser also for the curl command line. However, considering
            //    the two options:
            //      1. "unparse" the oclif parser output and keep using a custom
            //         curl parser as before
            //      2. remove the custom curl parser and use the oclif parser in
            //         both places
            //    the first option seems to provide more specific error messages,
            //    and it is not drastically more complex than the second one
            //    (calling the oclif parser directly outisde of the `parse()`
            //    method is non-trivial).
            parsed.argv.push(...(parsed.flags.data
                ? parsed.flags.data.flatMap((data) => ['-d', data])
                : []), ...(parsed.flags.request ? ['-X', parsed.flags.request] : []), ...(parsed.flags.url ? [parsed.flags.url] : []));
            return parsed;
        }
        catch (error) {
            if (!(error instanceof errors_2.CLIParseError)) {
                throw error;
            }
            const unsupportedFlags = error.parse.output?.nonExistentFlags;
            if (!unsupportedFlags || unsupportedFlags.length === 0) {
                throw error;
            }
            // show a curl-specific error message for unsupported flags
            throw new errors_1.CLIError(`Unsupported curl flag${unsupportedFlags.length > 1 ? 's' : ''}: ${unsupportedFlags.join(', ')}.` +
                ` If this is a blocker for you, please let us know on Discord` +
                ` (${constants_1.STEPZEN_DISCORD_URL})`);
        }
    }
    async getImportOptionsInteractively(defaults = {}) {
        const questions = inquirer.overrideDefaults([
            {
                name: 'url',
                message: 'Endpoint URL or a full curl command',
            },
            {
                name: 'pathParams',
                message: 'Parameters for endpoint URL path',
            },
            {
                name: 'queryName',
                message: 'Query name to use when generating schema (leave blank to use defaults)',
            },
            {
                name: 'rootType',
                message: 'Query type name to use when generating schema (leave blank to use defaults)',
            },
            questions_1.ImportQuestions.prefix(),
        ], defaults);
        const answers = await inquirer.prompt('import-curl', questions);
        const { result: curlArgs, error: curlError } = (0, curl_parser_1.parseCurlArgv)((0, string_argv_1.default)(answers.url));
        if (curlError) {
            this.log();
            this.log(chalk.red('A problem occurred while parsing the curl command:\n', curlError.message), '\nPlease enter a URL or a supported curl command.');
            this.log();
            return this.getImportOptionsInteractively(answers);
        }
        const { result: pathParams, error: pathParamsError } = (0, path_params_parser_1.parsePathParamsPattern)(curlArgs.url, answers.pathParams);
        if (pathParamsError) {
            this.log();
            this.log(chalk.red('A problem occurred while parsing path parameters pattern:\n', pathParamsError.message));
            this.log();
            this.log(`Please enter a path parameter specification that` +
                ` can be formed by taking the original path and replacing the variable` +
                ` segments with ${chalk.bold('$paramName')} placeholders.`);
            this.log();
            this.log('Example:\n' +
                `\tendpoint URL: https://example.com/users/jane/posts/12\n ` +
                `\tpath parameters: /users/${chalk.bold('$userId')}/posts/${chalk.bold('$postId')}`);
            this.log();
            return this.getImportOptionsInteractively(answers);
        }
        return {
            curlArgs,
            queryName: answers.queryName,
            rootType: answers.rootType,
            typePrefix: answers.typePrefix.trim() === ''
                ? undefined
                : answers.typePrefix.trim(),
            pathParams,
        };
    }
}
exports.default = ImportCurl;
ImportCurl.description = `Import a schema for a REST endpoint into your GraphQL API (uses the curl` +
    ` syntax).` +
    `\n` +
    chalk `\n{bold stepzen import curl} automatically introspects a REST` +
    ` endpoint, generates a GraphQL schema for accessing this endpoint` +
    ` through a StepZen API, and adds the generated types and a query` +
    ` field into your GraphQL schema.`;
ImportCurl.flags = {
    ...import_command_1.ImportCommandBase.flags,
    prefix: flags_1.ImportFlags.prefix(),
    data: core_1.Flags.string({
        char: 'd',
        hidden: true,
        aliases: ['data-ascii', 'data-raw', 'data-binary'],
        multiple: true,
    }),
    request: core_1.Flags.string({
        char: 'X',
        hidden: true,
    }),
    url: core_1.Flags.string({
        hidden: true,
        multiple: true,
    }),
    header: flags_1.ImportFlags.header(),
    'header-param': flags_1.ImportFlags.headerParam(),
    'query-name': core_1.Flags.string({
        description: 'Property name to add to the Query type as a way to' +
            ' access the imported endpoint',
    }),
    'query-type': core_1.Flags.string({
        description: 'Name for the type returned by the curl request in the ' +
            `generated schema. The name specified by ${chalk.bold('--query-type')} is not prefixed by ${chalk.bold('--prefix')} if both flags are present.`,
    }),
    'path-params': core_1.Flags.string({
        description: `Specifies path parameters in the URL path.` +
            ` Can be formed by taking the original path and replacing the` +
            ` variable segments with ${chalk.bold('$paramName')} placeholders.` +
            `\n` +
            `\nExample:` +
            `\nstepzen import curl https://example.com/users/jane/posts/12` +
            ` --path-params` +
            ` '/users/${chalk.bold('$userId')}/posts/${chalk.bold('$postId')}'`,
    }),
};
// allow any number of arguments to support `import curl [url] [curl flags and options]`
ImportCurl.strict = false;
//# sourceMappingURL=curl.js.map
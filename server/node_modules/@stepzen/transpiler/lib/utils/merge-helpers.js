"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeTypeFromSchema = exports.removeQueryMutationFromSchema = exports.mergeTypeIntoSchema = exports.mergeQueryMutationIntoSchema = exports.getSchema = exports.getExtensions = exports.getConfiguration = exports.findTypeInSchema = exports.findQueryMutationInSchema = exports.findNextAvailableSubfolder = exports.dedupeTempFolder = void 0;
const debug = require("debug");
const graphql_1 = require("graphql");
const utilities_1 = require("graphql/utilities");
const fetch_1 = require("@stepzen/fetch");
const fsx = require("fs-extra");
const glob = require("glob");
const os = require("os");
const path = require("path");
const lodash_1 = require("lodash");
const graphql_helpers_1 = require("../utils/graphql-helpers");
const constants_1 = require("./constants");
const configure_1 = require("../actions/configure");
const transpile_1 = require("../actions/transpile");
const rmtemp_1 = require("./rmtemp");
const dedupeTempFolder = (dirpath) => {
    do {
        dirpath = (0, lodash_1.replace)(dirpath, os.tmpdir(), '');
    } while (dirpath.includes(os.tmpdir()));
    dirpath = path.join(os.tmpdir(), dirpath);
    return dirpath;
};
exports.dedupeTempFolder = dedupeTempFolder;
const findNextAvailableSubfolder = (folder, name) => {
    let subfolder = name;
    let counter = 1;
    while (fsx.existsSync(path.join(folder, subfolder))) {
        const suffix = `${counter++}`.padStart(2, '0');
        subfolder = `${name}-${suffix}`;
    }
    return subfolder;
};
exports.findNextAvailableSubfolder = findNextAvailableSubfolder;
const isQueryMutationSubscription = (ancestors) => {
    if (Array.isArray(ancestors[ancestors.length - 1])) {
        return false;
    }
    const ancestor = ancestors[ancestors.length - 1];
    return (ancestor.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION &&
        ['Query', 'Mutation', 'Subscription'].includes(ancestor.name.value));
};
const findQueryMutationInSchema = (name, files) => {
    for (const file of files) {
        let found = false;
        (0, graphql_1.visit)(file.ast, {
            FieldDefinition(node, _key, _parent, _path, ancestors) {
                if (isQueryMutationSubscription(ancestors) &&
                    node.name.value === name) {
                    found = true;
                    return graphql_1.BREAK;
                }
            },
        });
        if (found)
            return true;
    }
    return false;
};
exports.findQueryMutationInSchema = findQueryMutationInSchema;
const findTypeInSchema = (name, files) => {
    for (const file of files) {
        let found = false;
        (0, graphql_1.visit)(file.ast, {
            ObjectTypeDefinition(node) {
                if (node.name.value === name) {
                    found = true;
                    return graphql_1.BREAK;
                }
            },
        });
        if (found)
            return true;
    }
    return false;
};
exports.findTypeInSchema = findTypeInSchema;
const getConfiguration = async (directories, silent = false, answers = {}) => {
    const tmp = path.join(os.tmpdir(), `stepzen-tmp-config-${Date.now()}`);
    fsx.ensureDirSync(tmp);
    try {
        for (const directory of directories) {
            const configs = [
                ...glob.sync('**/config.yaml', { cwd: directory }),
                ...glob.sync('**/stepzen.config.json', { cwd: directory }),
            ];
            for (const config of configs) {
                const configFolder = path.join(directory, config);
                let writeFolder = path.join(tmp, directory, config);
                writeFolder = (0, exports.dedupeTempFolder)(writeFolder);
                const content = fsx.readFileSync(configFolder, 'utf8');
                fsx.ensureFileSync(writeFolder);
                fsx.writeFileSync(writeFolder, content, { mode: 0o600 });
            }
        }
        const configuration = await (0, configure_1.default)(tmp, silent, answers);
        return configuration;
    }
    finally {
        (0, rmtemp_1.rmtemp)(tmp);
    }
};
exports.getConfiguration = getConfiguration;
const getExtensions = async () => {
    const baseurl = constants_1.STEPZEN_SERVER_URL.replace('.io', '.net').replace('{account}', 'stepzen');
    const url = `${baseurl}/directives.graphql`;
    const startedAt = new Date().getTime();
    debug('stepzen:extensions')(`[transpiler] fetching StepZen extensions from ${url}`);
    const response = await (0, fetch_1.default)(url);
    const text = await response.text();
    const doneAt = new Date().getTime();
    debug('stepzen:extensions')(`[transpiler] fetched extensions (${text.length} bytes, ${doneAt - startedAt} ms)`);
    return text;
};
exports.getExtensions = getExtensions;
const getSchema = async (directory, extensions) => {
    const transpiled = await (0, transpile_1.default)(directory);
    return (0, utilities_1.buildSchema)(`${extensions}${os.EOL}${transpiled.schema}`);
};
exports.getSchema = getSchema;
const mergeQueryMutationIntoSchema = (type, files) => {
    files = files.map((file) => {
        return {
            ...file,
            ast: (0, graphql_1.visit)(file.ast, {
                FieldDefinition(node, _key, _parent, _path, ancestors) {
                    if (isQueryMutationSubscription(ancestors) &&
                        node.name.value === type.name.value) {
                        const directives = (0, graphql_helpers_1.cloneDeep)(type.directives);
                        const mutated = (0, graphql_helpers_1.cloneDeep)(node);
                        mutated.directives = directives;
                        return mutated;
                    }
                },
            }),
        };
    });
    return files;
};
exports.mergeQueryMutationIntoSchema = mergeQueryMutationIntoSchema;
const mergeTypeIntoSchema = (type, files) => {
    files = files.map((file) => {
        return {
            ...file,
            ast: (0, graphql_1.visit)(file.ast, {
                ObjectTypeDefinition(node) {
                    if (node.name.value === type.name.value) {
                        const directives = (0, graphql_helpers_1.cloneDeep)(type.directives);
                        const fields = (0, graphql_helpers_1.cloneDeep)(type.fields);
                        const mutated = (0, graphql_helpers_1.cloneDeep)(node);
                        mutated.directives = directives;
                        mutated.fields = fields;
                        return mutated;
                    }
                },
            }),
        };
    });
    return files;
};
exports.mergeTypeIntoSchema = mergeTypeIntoSchema;
const removeQueryMutationFromSchema = (name, files) => {
    files = files.map((file) => {
        return {
            ...file,
            ast: (0, graphql_1.visit)(file.ast, {
                FieldDefinition(node, _key, _parent, _path, ancestors) {
                    if (isQueryMutationSubscription(ancestors) &&
                        node.name.value === name) {
                        return null;
                    }
                },
            }),
        };
    });
    return files;
};
exports.removeQueryMutationFromSchema = removeQueryMutationFromSchema;
const removeTypeFromSchema = (name, files) => {
    files = files.map((file) => {
        return {
            ...file,
            ast: (0, graphql_1.visit)(file.ast, {
                ObjectTypeDefinition(node) {
                    if (node.name.value === name) {
                        return null;
                    }
                },
            }),
        };
    });
    return files;
};
exports.removeTypeFromSchema = removeTypeFromSchema;
//# sourceMappingURL=merge-helpers.js.map
"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStepZenDockerImage = exports.fetchCurrentDockerImageInfo = exports.removeCredentialsAndServiceFromConfigFile = exports.writeCredentialsAndServiceToConfigFile = exports.writeConfiguration = exports.readConfiguration = exports.importConfiguration = exports.ensureValidConfiguration = void 0;
// This file contains methods for managing configuration
const errors_1 = require("@oclif/core/lib/errors");
const debug = require("debug");
const fs = require("fs");
const uuid_1 = require("uuid");
const path = require("path");
const yaml = require("yaml");
const fetch_1 = require("@stepzen/fetch");
const constants_1 = require("./constants");
const stepzen_sdk_1 = require("./stepzen-sdk");
/**
 * Ensure that the `stepzen-config.yaml` file exists and has valid content.
 * Cover 3 cases:
 *  - file does not exist (this is the first time the CLI is run)
 *      -> initialize the config file and add a UUID into it
 *  - file exists but does not include a UUID (it was created by an earlier
 *    version of the CLI)
 *       -> add a UUID into the existing config file
 *  - file exists, has stepzen credentials, but does not include an API key
 *    (it was created by an earlier version of the CLI)
 *       -> either fetch the API key from StepZen or remove logged in credentials
 *
 * @param {*} maybeConfiguration raw contents of the configuration file
 */
const ensureValidConfiguration = async (maybeConfiguration) => {
    let modified = false;
    let configuration = { ...maybeConfiguration };
    // ensure configuration exists
    if (!maybeConfiguration) {
        modified = true;
    }
    // ensure configuration has a UUID
    if (!configuration.uuid) {
        configuration.uuid = (0, uuid_1.v4)();
        debug('stepzen:configuration')(`Generated a new machine UUID: ${configuration.uuid}`);
        modified = true;
    }
    // ensure a logged-in configuration includes an API key
    if (configuration.account && !configuration.apikey) {
        try {
            debug('stepzen:configuration')(`Fetching an API key for account ${configuration.account}`);
            const { result: apikey, configuration: effectiveConfig } = await (0, stepzen_sdk_1.tryZenCtl2ThenZenCtl1)(configuration, async (stepzen) => {
                const credentials = await stepzen.login(configuration.adminkey, configuration.account);
                return stepzen.version === 'v1'
                    ? credentials.apikey
                    : credentials.apiKeys[0];
            });
            // eslint-disable-next-line require-atomic-updates
            configuration = { ...effectiveConfig, apikey };
        }
        catch (error) {
            if (error instanceof Error &&
                error.message.includes('Your credentials are invalid')) {
                debug('stepzen:configuration')(`Removing the stored account credentials because logging in failed. ${error}`);
                delete configuration.account;
                delete configuration.adminkey;
                delete configuration.apikey;
            }
            else {
                // ignore other errors
            }
        }
        modified = true;
    }
    return {
        configuration: configuration,
        modified,
    };
};
exports.ensureValidConfiguration = ensureValidConfiguration;
const importConfiguration = async (filepath) => {
    if (!fs.existsSync(filepath)) {
        throw new errors_1.CLIError('Configuration file does not exist');
    }
    const content = fs.readFileSync(filepath, 'utf8');
    try {
        return yaml.parse(content);
    }
    catch {
        throw new errors_1.CLIError('Configuration file is not valid yaml');
    }
};
exports.importConfiguration = importConfiguration;
const readConfiguration = async (configFileName = constants_1.STEPZEN_CONFIG_FILE) => {
    let maybeConfiguration = null;
    // If the configuration comes from an env var, use it
    if (process.env.STEPZEN_CONFIG_CONTENT) {
        try {
            maybeConfiguration = yaml.parse(process.env.STEPZEN_CONFIG_CONTENT);
        }
        catch (error) {
            debug('stepzen:configuration')(`Could not parse the STEPZEN_CONFIG_CONTENT env var as YAML: ${error}`);
        }
    }
    else {
        const configFilePath = path.join(constants_1.STEPZEN_CONFIG_DIRECTORY, configFileName);
        try {
            maybeConfiguration = await (0, exports.importConfiguration)(configFilePath);
        }
        catch (error) {
            debug('stepzen:configuration')(`Could not read the config file at ${configFilePath}: ${error}`);
        }
    }
    const { configuration } = await (0, exports.ensureValidConfiguration)(maybeConfiguration);
    debug('stepzen:configuration')(configuration);
    return configuration;
};
exports.readConfiguration = readConfiguration;
const writeConfiguration = async (configuration, configFileName = constants_1.STEPZEN_CONFIG_FILE) => {
    // Generate YAML from the configuration
    const content = yaml.stringify(configuration);
    // Check that the configuration directory exists. If not, create it.
    if (!fs.existsSync(constants_1.STEPZEN_CONFIG_DIRECTORY)) {
        fs.mkdirSync(constants_1.STEPZEN_CONFIG_DIRECTORY);
    }
    // Write the configuration file. Overwrites if it already exists.
    const configFilePath = path.join(constants_1.STEPZEN_CONFIG_DIRECTORY, configFileName);
    fs.writeFileSync(configFilePath, content, { mode: '600' });
    return (0, exports.readConfiguration)(configFileName);
};
exports.writeConfiguration = writeConfiguration;
const writeCredentialsAndServiceToConfigFile = async (credentials, serviceInstance) => {
    const credentialsV1 = 'apiKeys' in credentials
        ? {
            account: credentials.account,
            adminkey: credentials.adminKey,
            apikey: credentials.apiKeys[0],
        }
        : credentials;
    const oldConfig = await (0, exports.readConfiguration)();
    const newConfig = {
        ...oldConfig,
        ...credentialsV1,
        ...(serviceInstance ? { serviceInstance } : {}),
    };
    const writtenConfig = await (0, exports.writeConfiguration)(newConfig);
    return {
        ...newConfig,
        ...writtenConfig,
    };
};
exports.writeCredentialsAndServiceToConfigFile = writeCredentialsAndServiceToConfigFile;
const removeCredentialsAndServiceFromConfigFile = async () => {
    const configuration = await (0, exports.readConfiguration)();
    delete configuration.account;
    delete configuration.apikey;
    delete configuration.adminkey;
    delete configuration.serviceInstance;
    await (0, exports.writeConfiguration)(configuration);
    return configuration;
};
exports.removeCredentialsAndServiceFromConfigFile = removeCredentialsAndServiceFromConfigFile;
let _currentDockerImageInfo;
async function fetchCurrentDockerImageInfo() {
    if (_currentDockerImageInfo) {
        debug('stepzen:configuration')(`using cached Docker image info: ${JSON.stringify(_currentDockerImageInfo)}`);
        return _currentDockerImageInfo;
    }
    try {
        const config = await (0, exports.readConfiguration)();
        const { result: userAgent } = await (0, stepzen_sdk_1.tryZenCtl2ThenZenCtl1)(config, stepzen => Promise.resolve(stepzen.userAgent));
        // Not using constants.ts/getZenServUrlTemplate() here because this
        // needs to be fetch from the StepZen cloud even when running locally.
        const account = 'account' in config ? config.account : 'stepzen';
        const url = `https://stepzen.com/cli/config/docker?account=${account}&token=${config.uuid}`;
        debug('stepzen:configuration')(`fetching Docker image info from ${url}`);
        const result = await (0, fetch_1.default)(url, {
            headers: { 'user-agent': userAgent },
        });
        const text = await result.text();
        debug('stepzen:configuration')(`\t--> fetched ${text}`);
        const json = JSON.parse(text);
        // eslint-disable-next-line require-atomic-updates
        _currentDockerImageInfo = {
            image: json.image,
            tag: json.tag,
        };
        debug('stepzen:configuration')(`using Docker image info: ${JSON.stringify(_currentDockerImageInfo)}`);
        return _currentDockerImageInfo;
    }
    catch (error) {
        debug('stepzen:configuration')(`failed to fetch Docker image info: ${error}`);
        return undefined;
    }
}
exports.fetchCurrentDockerImageInfo = fetchCurrentDockerImageInfo;
async function getStepZenDockerImage() {
    const env = {
        image: process.env.STEPZEN_DOCKER_IMAGE,
        tag: process.env.STEPZEN_DOCKER_TAG,
    };
    const hasImageInEnv = env.image && (env.image.includes(':') || env.tag);
    let current;
    if (!hasImageInEnv) {
        // Do not fetch the current Docker image name and tag if they won't be used.
        //
        // This also means that when the `STEPZEN_DOCKER_IMAGE` and `STEPZEN_DOCKER_TAG`
        // env vars are set, using the local Docker feature leaves no trace in the
        // stepzen.net HTTP logs.
        current = await fetchCurrentDockerImageInfo();
    }
    const image = env.image || current?.image || constants_1.DEFAULT_STEPZEN_DOCKER_IMAGE;
    const tag = env.tag || current?.tag || constants_1.DEFAULT_STEPZEN_DOCKER_TAG;
    return image.includes(':') ? image : `${image}:${tag}`;
}
exports.getStepZenDockerImage = getStepZenDockerImage;
//# sourceMappingURL=configuration.js.map
"use strict";
// Copyright IBM Corp. 2020, 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseHeaderFlags = exports.writeSdlAndConfig = exports.queryIntrospectionService = void 0;
const errors_1 = require("@oclif/core/lib/errors");
const fetch_1 = require("@stepzen/fetch");
const transpiler = require("@stepzen/transpiler");
const debug = require("debug");
const fsx = require("fs-extra");
const lodash_1 = require("lodash");
const os = require("os");
const path = require("path");
const prettier = require("prettier");
const errors_2 = require("../shared/errors");
const header_1 = require("../shared/header");
const header_params_parser_1 = require("../shared/header-params-parser");
const rmtemp_1 = require("../shared/rmtemp");
const utils_1 = require("../shared/utils");
const queryIntrospectionService = async (serverUrl, query) => {
    debug('stepzen:introspection')(serverUrl);
    const queryString = `query (
    ${Object.entries(query.variables).map(([id, { type }]) => `$${id}: ${type}`)} 
      ) { 
        ${query.operation}(${Object.keys(query.variables).map(id => `${id}: $${id}`)}) {
            sdl
            config
          } 
        }`;
    debug('stepzen:introspection')(queryString);
    debug('stepzen:introspection')(query.variables);
    const payload = JSON.stringify({
        query: queryString,
        variables: (0, lodash_1.mapValues)(query.variables, ({ value }) => value),
    });
    debug('stepzen:introspection')(payload);
    let response;
    try {
        response = await (0, fetch_1.default)(serverUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: payload,
        });
    }
    catch (error) {
        debug('stepzen:introspection')(`Network error when calling the introspection service: ${error}`);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    if (!response.ok) {
        debug('stepzen:introspection')(`HTTP failure response from the introspection service:` +
            ` ${response.status} ${response.statusText}`);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    let json;
    try {
        const text = await response.text();
        debug('stepzen:introspection')(text);
        json = JSON.parse(text);
    }
    catch (error) {
        debug('stepzen:introspection')(`invalid JSON response from the introspection service: ${error}`);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    if (!json.data && !json.errors) {
        debug('stepzen:introspection')('expected the response from the JSON introspection service ' +
            'to contain either `data` or `errors`');
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    if (json.errors) {
        const compileError = (error) => {
            // nicer error messages for selected cases
            if (error.extensions?.exception ===
                'net.snowflake.client.jdbc.SnowflakeSQLException' &&
                error.extensions?.cause?.match(/Message: HTTP status=403/i)) {
                return 'The provided Snowflake account ID appears invalid.';
            }
            if (error.extensions?.exception ===
                'net.snowflake.client.jdbc.SnowflakeSQLException' &&
                error.extensions?.cause?.match(/Incorrect username or password was specified/i)) {
                return 'Incorrect Snowflake username or password.';
            }
            return (error.message +
                // error.extensions.Message: DB introspection API (e.g. wrong password)
                (error.extensions?.Message ? `: ${error.extensions.Message}` : '') +
                // error.extensions.details: REST instrospection API (e.g. 401 / unauthorized)
                (error.extensions?.details
                    ? `: ${JSON.stringify(error.extensions.details)}`
                    : '') +
                // error.extensions.cause: DB introspection API (e.g. --db-include=views-only and there are no views)
                (error.extensions?.cause
                    ? `: ${JSON.stringify(error.extensions.cause)}`
                    : ''));
        };
        return { error: { message: json.errors.map(compileError).join('\n') } };
    }
    if (!json.data[query.operation]) {
        debug('stepzen:introspection')('expected the response from the introspection service ' +
            `to contain a \`${query.operation}\` object`);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    const { config, sdl } = json.data[query.operation];
    if (!config && !sdl) {
        debug('stepzen:introspection')('expected the response from the introspection service ' +
            `to contain at least one of \`${query.operation}.config\` or ` +
            `\`${query.operation}.sdl\` properties`);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    return { result: { config, sdl } };
};
exports.queryIntrospectionService = queryIntrospectionService;
const writeSdlAndConfig = async ({ name, source, mergeTypes = false, onConflict, response, }) => {
    const { config, sdl } = response;
    // write out the generated config and schema files
    const tmp = path.join(os.tmpdir(), `stepzen-introspection-${Date.now()}`);
    fsx.ensureDirSync(tmp, 0o700);
    try {
        if (config) {
            fsx.writeFileSync(path.join(tmp, 'config.yaml'), prettier.format(config, { parser: 'yaml' }), { mode: 0o600 });
        }
        if (sdl) {
            fsx.writeFileSync(path.join(tmp, 'index.graphql'), prettier.format(sdl, { parser: 'graphql' }));
        }
        const result = await transpiler.merge(source, {
            name: name,
            source: tmp,
        }, {
            answers: {},
            output: null,
            silent: true,
            mergeTypes,
            onConflict,
            extensions: await (0, utils_1.getStepZenExtensions)(),
        });
        return { outPath: result };
    }
    finally {
        (0, rmtemp_1.rmtemp)(tmp);
    }
};
exports.writeSdlAndConfig = writeSdlAndConfig;
const parseHeaderFlags = (headerFlagValues, headerParamFlagValues) => {
    const headers = [];
    if (headerFlagValues) {
        headerFlagValues.forEach(value => {
            const { result, error } = (0, header_1.parseHeader)(value);
            if (error) {
                throw new errors_1.CLIError(error.message);
            }
            // A `null` from parseHeader() means a header should NOT be
            // sent. This is not supported by zenserv / the introspection service
            // so the CLI simply omits such headers
            if (result) {
                headers.push(result); // header
            }
        });
    }
    const { result, error } = (0, header_params_parser_1.makeHeaders)(headers, headerParamFlagValues);
    if (error) {
        throw new errors_1.CLIError(error.message);
    }
    return result;
};
exports.parseHeaderFlags = parseHeaderFlags;
//# sourceMappingURL=helpers.js.map